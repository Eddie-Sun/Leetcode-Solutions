//Apr 7 2024
--Review AdjList Graph Design--

Example: 

{
    1: {2, 3},
    2: {4},
    3: {4},
    4: {1}
}

class graph:
	def __init__(self): 
		self.adjList = {}

	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList:
			self.adjList[dst] = set()
		self.adjList[src].add(dst)
		
	def removeEdge(self, src, dst) -> bool: 
		if src not in self.adjList or dst not in self.adjList:
			return False
		self.adjList[src].remove(dst)
		return True

	def hasPath(self, src, dst) -> bool:
		vistied = set()
		return _dfs(src, dst, vistied)
		return bfs(src, dst, visited)

	def _dfs(self, src, dst, visited) -> bool:
		if src == dst:
			return True
		if src not in visited:
			visted.add(src)
			for neighbor in adjList[src]:
				return _dfs(neighbor, dst, visited)
		return False

	Ok you fumbled the DFS.

	if src not in visted:
		visited.add(src)
		for neightbor in self.adjList[src]:
			if self.dfs(neighbor, dst, visited):
				return True
	return False

	def bfs(self, src, dst, visited) -> bool:
		vistied.add(src)
		queue = deque()
		queue.append(src)

		while queue:
			cur = queue.popleft()
			if cur = dst:
				return True
			visited.add(cur)
			for neighbors in self.adjList[cur]:
				if neighbor not in visited:	
					queue.append(neighbor)
					vistied.add(neighbor) 
		return False

//Apr 5-6 2024
**Valid Perfect Square**
The brute for binary search method. You start off with range(0->num). 

L, R = 0, nums
while L < R:
	M = (L + R) // 2
	if M * M < nums:
		L = M
	if M * M > nums:
		R = M
	if M * M == nums:
		return True 
return False

Correct solution: 

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        L, R = 0, num
        while L <= R:
            M = (L + R) // 2
            if M * M < num:
                L = M + 1
            elif M * M > num:
                R = M - 1
            else:
                return True
        return False

The key insight here is that L = M + 1 and R = M - 1 is generalizable to most binary search questions.

**Arranging Coins**
You have n coins and want to build a staircase with coins. Stairs have k rows where ith row have ith coins. 

Arr pattern: sum of coins:
[1,3,6,10,15,21] n
 1 2 3 4  5  6   R

21/6. Whats the formula that maps the R to n (number of coins?). The brute force method is to go through each row and do n+1 for each new row till we run out of coins to fill a row. Lets try that:

        row = 0
        while n >= 0:
            row += 1
            n -= row
        return row - 1

Now lets use binary search to solve this problem. Recall binary search is a method to cut the search space by 1/2 each time. Lets set the ceiling to n, and cut the search space by 1/2 each time. How do we go from R -> n?

If we think about it geometrically, the staircase is 1/2 a square. So to get n from row we can do:

n = ((r * r + r) // 2)

Rearrange

n * 2 = r*r + r
n * 2 = r(r+1)
We can use ax^2 + bx + c = 0

The solution for r = (-1 + (1 + 8 * n) ** 0.5) / 2. You can just floor that for the solution. 

Also remeber that the formula for arthemtic sum = m + m + 1 // 2
--Review of AdjLit BFS, DFS, Desgin--

Lets start with the design of a graph:

class graph:
	def __init__(self):
		self.adjList = {}
	
Ok Q: What does the __init__ method actually do in this context? Guess, it inialzies the adjList to a empty hashmap. And the self.adjList simply means that there could be mutiple instances of the same adjList object. 

Ok, update in knowledge: __init__ is a constuctor which is auto created when new instance of class is made. The word self signifies that the method belongs to cur instance of class meaning each instance of graph can have own seperate adjList ditc. 

	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList:
			self.adjList[dst] = set()
		self.adjList[src].add(dst)

	def removeEdge(self, src, dst) -> bool:
		if src not in self.adjList[src] or dst not in self.adjList[dst]:
			return False
		self.adjList[src].remove(dst)
		return True

	def hasPath(self, src, dst) -> bool:
		vistied = set()
		return self._dfs(src, dst, vistied)

I noticed that when you call another function within the func def such as ins hasPath, you dont have to manually add self as a param? Ex return _dfs(src, dst, vistied). This is because when calling another method from the same class, the self is implicity passed as the first param by python.

	def _dfs(self, src, dst, visisted)-> bool:
		if src == dst:
			return True
		
		if src not in visited:
			for neighbor in self.adjList.get(src, []): #we dont have to format it like that
				visited.add(neighbor)
				if self._dfs(neighbor, dst, vistied):
					return True
		return False

Try again in the afternoon:
	
	def _dfs(self, src, dst, visited) -> bool:
		if src == dst:
			return True

		if src not in visted:
			visted.add(src)
			for neighbor in adjList[src]:
				if _dfs(neighbor, dst, visited):
					return True
		return False

Ok, there might be still some small problems with my implementaion: The biggest being that we do not mark visited within the for loop. By doing that, it means we prematurely, mark the nodes as visited. its not like it will always fail, but it will add un-needed complexity.

Aight, let us try with BFS. Remeber for bfs, you need to have a queue, and you keep popping off level by level.

	def _bfs(self, src, dst, visited) -> bool:
		queue = deqeue()
		queue.add(src)
		visited.add(src)
		while queue: 
			for _ in range(len(queue))
				cur = queue.popleft()
				if cur.val == target:
					return True
				for neighbor in AdjList[cur]:
					if neightbor not in visted:
						queue.append(neighbor)
						visted.add(neightbor)
		return False

A few corrections:
1) for queue you do append instead of add- its not a set
2) you dont do cur.val, you look right at cur. 
					
Example: 

{
    1: {2, 3},


    2: {4},
    3: {4},
    4: {1}
}

**Minimum Size Subarrary Sum
Return min length of subarray that sum is greater or equal to target. Else return 0. This is a sliding window problem. You start off with a left pointer and a right pointer @ 0. L pointer shrinks the window (while sum of sub array >= target, shrink left, subtract l val 
from sub array), else, R++ (we can just do that in a for loop). return length.

I read the question wrong the first time. 

L, total = 0, 0
length, min = 0, float('inf')
for R in range(len(nums)):
	total += num[R]
	length += 1
	while total >= target:
		min_length = min(length, min_length) 
		L += 1
		total -= nums[L]
		length -= 1
return min_length if min_length != float('inf') else min_length

Corrected code: 

L, total = 0, 0
length, min_length = 0, float('inf')
for R in range(len(nums)):
    total += nums[R]  # Corrected typo here
    length += 1
    while total >= target:
        min_length = min(length, min_length) 
        total -= nums[L]  # Subtract the current L, then increment
        L += 1
        length -= 1
return 0 if min_length == float('inf') else min_length

**Find All Duplicates in an Array
Ok the big brained solution to this is that you mark the indexs you visted by making it -. And the visit goes to the index of the val. [3,2,2,4], the first index marks 4 neg. And by traversing the abs vals of the arr.

res = []
for num in nums:
	index = abs(num) - 1
	if nums[index] < 0:
		res.append(num + 1)
	else: #mark as -
		nums[index] = -nums[index]
return res

Given nums 1-n where each int appears once. Return a arr where intergers appear twice. There is the hash set solution which is O(n) time and O(n) space. 

dup, res = set(), []
for num in nums:
	if num not in dup:
		dup.add(num)
	else:
		res.append(num)
return res

Ok. Now how do we do it without a hash set? We cant sort it because it uses O(n) can we use the XOR operation? Everythime its 0, we append the res?

res = []
for num in nums:
	
Nope. The XOR method seems to only work for one repeat val due to the cummalitive property.

--Design Graph--
Example of the list: 

{
    1: {2, 3},
    2: {4},
    3: {4},
    4: {1}
}

Keep in mind whn we are doing if src not in self.adjList or dst not in self.adjList, we are looking at the keys not the vals of the keys.

class Graph:
	def __init__(self)
		self.adjList = {}
	
	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList:
			self.adjList[dst] = set()
		self.adjList[src].add(dst)

	def removeEdge(self, src, dst):
		if src not in self.adjList or dst not in self.adjList:
			return False
		self.adjList[src].remove(dst)
		return True
	
	def hasPath(self, src, dst): #this is just DFS no?
		visited = set()
		return self._dfs(src, dst, visited)

	def _dfs(self, src, dst, visited):
		if src == dst:
			return True
		visited.add(src)
		for neighbor in self.adjList.get(src, []):
			if neighbor not in visited:
				if self._dfs(neightbor, dst, visited):
					return True
		return False

**Single Number
I completely forgot about XOR operations. What you do is set res = 0, and for num in nums, res ^= num. 

[4,1,2,1,2]
res ^= 4 = 0 ^= 4 = 4
4 ^= 1   = 0

Ok, XOR happens at the binary level. Some useful proofs are: A number XORed with itself = 0. A number XORed with 0 is the number itself. XOR is commulative and associative. This means that the order of XOR operations dont matter. 

DFS(node, target, adjList, visited):
	if not node:
		return 0
	if node.val == target:
		return 1

	count += 1
	visited.add(node)
	for neighbor in adjList[node]:
		count += dfs(node, target, adjList, visited)
	visted.remove(node)
	return count

def BFS(node, adjList, target):
	visited = set()
	visited.add(node)
	queue = deque()
	queue.add(node)
	length = 0
	
	while queue:
		for _ in range(length(queue)): 
			cur = queue.popleft()
			if cur.val == target:
				return length
			for neighbor in adjList[cur]:
				if neighbor not in visited:
					visited.append(neighbor)
					queue.add(neighbor)
			length += 1
	return length

//Apr 4 2024
**Clone Graph
It seems to me that if you want to make a deep copy of a graph given an reference node + adjacency list you want to do a BFS traversal. And if the new node is not copied, copy it to the new graph. BFT works best because it ensures that we connect every edge to every node, where we would have to manually backtrack for DFS.

Given that you written BFS earlier, what is the major diff here I'm thinking.

1) You have to make new nodes and copy the vals of each

--DFS, BFS practice --- 

Practicing traversals using adjacency lists. To initalize, you want a source and destination. 

class GraphNode: 
	def __init__(self, val):
		self.val = val
		self.neighbors = [] 

You could also use a hashmap:

adList = {'a':[], 'b':[]}. Example, given edges:
edges = [["A", "B"], ["B", "C"], ["B", "E"], ["C", "E"], ["E", "D"]]

build and adList:

for src, dst in edges:
	if src not in adList:
		adList[src] = []
	if dst not in adList:
		adList[dst] = []
	adjList[src].append(dst)

DFS to count paths to a target using back tracking:

visit = ()
def dfs(node, target, adList, visit):
	if node in visit:
		return 0
	if node == target:
		return 1

	count = 0
	vist.add(node)
	for neighbors in adList[node]:
		conut += dfs(node, target, adList, visit)
	vist.remove(node)

	return count

BFS to find shortest path to target:

def BFS(node, target, adjList):
	length = 0
	visit = set()
	visit.add(node)
	queue = deque()
	queue.append(node)

	while queue:
		for i in range(len(queue)):
			cur = queue.popleft()
			if cur == target:
				return length
			
			for neighbors in adjList[cur]:
				if neighbot not in vist:
					vist.add(neighbor)
					queue.append(neighbor)
			length +=1
	return length		


Try again:

adList = {'a':[], 'b':[]}
cur = 'a':[]

def BFS(node, target, adjList):
	queue = deque()
	queue.add(node)
	visit = set()
	visit.add(node)
	length = 0

	while queue:
		for i in range(len(queue))
			cur = queue.popleft()
			if cur.val == target:
				return length
			for neighbor in adjList[cur]:
				if neighbor not in visit:
					visit.add(neighbor)
					queue.append(neighbor)
		length += 1
	return length
			
**Unique Number of Occurrences
Given a arr of int. Return true if # of occurrences of each val is unique. Create a hash map: key = num -> val = # of num occurence. Loop through the vals, add to set, if in set, return False, else return True.

numCount, occurance = {}, set()
for num in range(len(arr)):
	if num not in numCount:
		numCount[num] = 1
	else:
		numCount[num] += 1

for val in numCount.values():
	if in occurance:
		return False
	else:
		occurance.add(val)

return True

**Max Consecutive Ones III
You are able to flip k bits. Find the total number of consq ones you can make. Q: where would the prefix sum be useful here? 

You do prefix sum. You have to make sure that index R - L + k == sum(r) - sum(l). You keep a running total of the max (R - L + k).

0,1,1,0,1
0,1,2,2,3

1st lets create a prefix sum. 

prefixSum = nums[1]
for i in range(1, len(nums)):
	prefixSum.append(num[i-1] + prefixSum[-1])

L, R = 0, 1

R you move by default. You only move L if you cannot create a consecutive one. You cant do L += 1 since it will be O(n^2). Can you move L -> R?

[1,1,1,0,0,0,1,1,1,1,0]
 l     r       

Had to search to to move l pointer to shrink the window in this sliding window q. We have to move l += 1 i think. And we don't have to calculate the sum of in between L <-> R @ O(n) time each time. So in total the time complexity is O(N).

If condition meet, r += 1, else while condition not meet l += 1. Track largestConsecutive. 

while R < len(nums):
	if R - L < prefixSum[R] - prefixSum[L] + k:
		largestConsecutive = max(largestConsecutive, prefixSum[R] - prefixSum[L] + k)
		R += 1
	else:
		L += 1

return largestConsecutive

Ok. Remeber, we only use prefix sum when we need to calculate the sum of elems in a range. We're not doing that here. 

onesUsed = k
while R < len(nums):
	if nums[R] == 0:
		oneUsed -= 1
		if oneUsed == 0: #shrink window
	R += 1

Ok, you need to practice your boiler plate code for sliding window problems:
There are two types of sliding windows 1) fixed size:

for r in range(len(nums)):
	if r - l + 1 > k:
		window.remove(nums[L])
		L += 1
	else nums[R] in window:
		return True
	window.add(nums[R])
return False

And then, there is var size:

for R in range(len(nums)):
	total += nums[R]
	while total >= target:
		length = min(R-L+1, length)
		total -= nums[L]
		L += 1
return 0 if length == float('inf') else length

So this is a sliding window problem. How would you solve it?

L, total = 0, 0
length = -float('inf')

for R in range(len(nums)):
	total += nums[R]
	while length < total + k:
		
#how do we shrink the window? while sums not consecutive. total += nums[R]. while total + k > R - L:
	length = max(R - L + 1, length)
	length -= nums[L]
	L += 1

L, total, length = 0, 0, 0
for R in range(len(nums)):
	total += nums[R]

	while R - L + 1 > total + k:
		total -= nums[L]
		L += 1

	length = max(R - L + 1, length)
return length


**Delete the Middle Node of a Linked List
Have a f and s pointer. Where f moves 2x s. delete @ s once f reaches end. For the base case of n = 1, delete first node. 

s = f = head
if not s.next:
	return None

if not s.next.next:
	return head.next

while f and f.next:
	s, f = s.next, f.next.next

return head

Proper solution: Handle 0 or 1 case: 

if not head or not head.next:
	return None

if not head.next.next: 
	head.next = None
	return Head

s = f = head
while f and f.next
	s, f = s.next, f.next.next
s.next = s.next.next

return head

1 3 4 7 1 2 6
      s
            f

You have to stop at s.prev

prev = s.next

if not head or not head.next:
	return None

s = f = head
prev = None

while f and f.next:
	prev, s, f = s, s.next, f.next.next

prev.next = slow.next
return head

//Apr 3 2024
**Longest Common Prefix
Sort. The prefix starts out as the shortest val. For each elem in inputs, compare to prefix. If val !=, reduce prefix size. Return prefix size or ''. We don't have to have a case for that.

strs.sorted()
pre = strs[0]
reduce = 0
for i in range(len(strs)):
	for j in range(len(pre - reduce)):
		if pre[j] != strs[j]:
			reduce += 1
return pre[:j]

Corrected code:

return '' if not strs

strs.sort()
pre, red = strs[0], 0

for i in range(1, len(strs)):
	for j in range(len(

**Implement strStr()
Learning about the KMP algo: The naive approach restarts the comparsion from next char of text everytime there is a mis match (this the m*n runtime). You want to build a prefix table (LPS Array). This also stands for longest proper prefix. You build it by setting an empty lsp == len of needle. 

Example for Prefix Table:
Pattern: "ABCDABD"
LPS Array: [0, 0, 0, 0, 1, 2, 0]

if set(needle) in set(haystack) return indexof(needle[0]). The problem with the set solution is that we do not perserve the order of the elems.

We'll use two pointers. L, R. Loop through with L. If left == first index of needle, save, the index. Then while needle, iterate through both needle and haystack. If same, return index, else, index -1, set L = R. 

for i in range(len(haystack)): 
	if haystack[i] == needle[0]:
		index = i
		for j in len(needle):
			if haystack[j] != needle[j]:
				i, index = j, -1
				break
return index

if not needle:
	return 0
for i in range(len(haystack) - len(needle) + 1): #we do this because we do not need to iterate through the entire len of the haystack if the elem left is < than len needle

        if not needle:
            return 0
        for i in range(len(haystack) - len(needle) + 1):
            if haystack[i] == needle[0]:
                match = True
                for j in range(1, len(needle)):
                    if haystack[i + j] != needle[j]:
                        match = False
                        break
                if match:
                    return i
        return -1

This code looks kind of messy. But its O(n) time and O(1) space. There is actually an algo that we could use called the KMP algo that: 

1) You create a prefix table for the needle. This stores the len of the longest proper prefix for each prefix of the needle. 

**Rewrite of Rotten oranges
R, C = len(grid), len(grid[0])
rotten = deque()
oranges += 1
dir = [[1,0],[-1,0],[0,1],[0,-1]]

for r in R:
	for c in C:
		if grid[r][c] == 2:
			rotten.append(r,c)
		if grid[r][c] == 1:
			oranges += 1

while rotten:
	for nr, nc in dir: 
		if not (0<= nr < R or 0<= nc < C) or grid[nr][nc] == 0 or grid[nr][nc] == 2:
			continue

	grid[nr][nc] == 2
	rotten.append(nr,nc)
	oranges -= 1
	
	if rotten:
		time += 1

return time if oranges == 0 else -1

The cracked version using python list comprehension:
	R, C, time 

//Apr 2 2024
**Rotton Oranges
You want to define R and C. Then you want to create a queue using deque(). The rotton oranges get popped. You also have to iterate through the entire grid to count the total number of oranges. If you hit a time where no oranges get rotten and there is more less rotten than total oranges, return -1, else return time.

R, C = len(grid)-1, len(grid[0])-1
rotten = deque()
oranges = 0

for r in range(R):
	for c in range(C):
		if grid[r][c] == 2:
			rotten.append((r,c), 0)
		elif grid[r][c] == 1
			fresh += 1
#Q: do we even need:
if fresh_oranges == 0:
	return 0

dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]

while rotten: 
	r, c = rotten.popleft()

	for dr, dc in dir:
		nr, nc = r + dr, c + dc

		if not (0<= nr < R and 0 <= nc < C):
			continue
		if grid[nr][nc] == 0 or grid[nr][nc] == 2:
			continue
		
		grid[nr][nc] = 2
		oranges -= 1
		queue.append((nr,nc))

	if queue: 
		time += 1

return time if oranges == 0 else -1 

//Apr 1 2024
**Rotton Oranges
For rotten oranges, we use a queue. Since we're counting the amount of time it takes for all the oranges to rot.

**Add Binary
Covert two strings into int, add, and convert to binary again. How do convert to int? Loop from the back, first val += 2^(i + 2). Do the same for other int. val1 + val2. To convert to binary:

val1, val2 = 0, 0
for i in range(len(a))-1, -1,-1):
	val1 += 2 ^ (i + 1)

How to turn into binary? Gave up on this. 

while num > 0:
	r = num % 2
	bin = str(r) + bin
	n // = 2

Do the loop again. 

Full code:

val1, val2, bin = 0, 0, ''
for i in range(len(a))-1, -1,-1):
	val1 += 2 ^ (i + 1)
for i in range(len(b))-1, -1,-1):
	val2 += 2 ^ (i + 1)
num = val1 + num2
while num > 0:
	r = num % 2
	bin = str(r) + bin
	n // = 2
return bin

another method = return bin(int(a,2) + int(b,2))
[2:]

for i in range(len(a) -1, -1, -1):
	if a[i] == 1:
		val1 += 2 ** (i + 1)

**Number of Islands
To find the number of islands in a grid, you want to loop through the grid and check for 1s. We can't just count the number of ones since mutiple ones can come together to form an island. Once you reach a 1, 1) mark it as visited 2) recursivly spread to other ones. Return count.

For the dfs, you have to check bounds. 

if not grid:
	return 0

R, C = len(grid)-1, len(grid[0])-1 
count = 0

dfs(r,c,grid):
	if r < 0 or r > R or c < 0 or c > C or grid[r][c] == 0:
		return
	else:
		grid[r][c] = '0'
		dfs(r + 1, c , grid)
		dfs(r - 1, c , grid)
		dfs(r, c + 1 , grid)
		dfs(r, c - 1 , grid)

for r in range(R):
	for c in range(C):
		if grid[r][c] == 1:
			count += 1
			dfs(r, c, grid)

return count

Q: How do we shorten this code. We can use list comprehensions: 

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(r, c):
            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == '1':
                grid[r][c] = '0'
                list(map(dfs, (r + 1, r - 1, r, r), (c, c, c + 1, c - 1)))

        return sum(dfs(r, c) or 1 for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == '1')


//Mar 31 2024
Find pivot index 1) find the max sum. Then keep a prefix sum of the left sum. And when sum - left sum = left sum, return index, else return false if reached end of the loop. One thing that you messed up it the bounds. If you ls to be at the bottom before the compare. And ls = total sum - left sum - n. Why the -n? 

Review of diagonal traverse:
Notice how that sum of every diagnoal row index is the same [0], [1,0],[0,1]. So we can add these to a hash map where the key is the sum of the index. We create this map using a O(n)^2 traversal looping with i and j. This way we have all the coordinates of the diagnoal traversal mapped out. Notice that the traversal occurs in alternating directions. We can append diagnal row and diagnal row reversed if % 2 != 0. Now loop through apended index elem and return res. 

Spiral Matrix:
For this question you have to figure out a method to 1) shrink the top, left, right, bottom bounds 2) change traversal directions. 

Todo: Number of Islands
Todo: Rotting Oranges

//Mar 29 2024
**Pascal's Triangle
Solved

//Mar 28 2024
**Pascal's Triangle

[1] a)       0
[1,1] b)     1
[1,2,1]      2 
[1,3,3,1]    3 
[1,4,6,4,1]  4

You're doing a len2 scan from l -> r. edges are always 1. Edge case a) b). Rest follows the two scan patt.

**Spiral Matrix
Q: How do you determine directions: right, down, left, up

Instead of subtracting row, and col, you can make sure top < bottom and left < right:

top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1
res = []

while top <= bottom and left <= right:
	#move right
	while j <= right:
		res.append(matrix[i][j])
		j += 1
	top += 1
	i += 1
	j -= 1

You define r, c = len(matrix), len(matrix[0]). Q: How do you do CW turns?

[0,0], [1,0], [2,0] | [1,2], [2,2] | [2,1], [2,0] | [1,0] | [1,1]
  0      1      2       3      4       3      2       1       2  -> Sum

[0,0], [1,0], [2,0]
[1,2], [2,2]
[2,1], [2,0]
[1,0]
[1,1]

We go from increase to decrease in len. There does not seem to be and clever math/indices trick to figure out like the diagonal traverse.

Brute force. Iterate i -> till R. Turn down. Iterate j till C. Turn Left

row, col, i, j, n, res = len(matrix) - 1, len(matrix[0]) - 1, 0, 0, 0, []
while row > 0 or col > 0:
	if i == 0: #traverse left
		for i in range(col):
			res.append(matrix[i][j])
		n+=1
	elif i == col: #traverse down
		for j in range(n, row):
			res.append(matrix[i][j])
	elif j == row: #traverse left
		for i in range(col - n, -1, -1):
			res.append(matrix[i][j]
	else: #traverse up
		for j in range(row - n -1, -1, -1):
			res.append(matrix[i][j]
return res

[-,-,-]
[|,-,|]
[-,-,|]

row = 3, 2
col = 3, 

Ok, it seems like you mesed up the cases for spiraling inwards. You want to set a top, bottom, left, right var. After each right top +1, move down right -1 since you're iterating from the back, move left bottom -=1, move up, l+=1


**Diagonal Traverse
d = {}
for i in range(len(matrix)):
	for j in range(len(matrix[i])):
		if i + j not in d:
			d[i + j] = [matrix[i][j]]
		else:
			d[i + j].append(matrix[i][j])

This builds the dict. The problem is 70% solved. Now you just have to figure out a method to traverse it in a zig zag pattern. You iterate through d[i+j] and if index % 2 == 0 down up, else go up down. Append to res.

for key, val in d.items():
	if key % 2 != 0:
		res.append(val)
	else:
		res.append(reversed(val))

I gave up and refered to GPT. The trick here is to sum i + j. The key big brained insight is that the elements on the same diagonal has the same i + j sum. Q: How does this help us? Well you could just do sum of diagnal - i to find j. 

Try mapping out [i,j] = [0,0] | [1,0], [0,1] | [0,2], [1,1], [2,0] | [2,1], [1,2] | [2,2]
Try to find the pattern of the [i,j] mapping. 

[0,0]
[1,0], [0,1]
[0,2], [1,1], [2,0]
[2,1], [1,2]
[2,2]

| [0,0] |
| [1,0], [0,1] |
| [2,0], [1,1], [0,2] |
| [3,0], [2,1], [1,2], [0,3] |
| [4,0], [3,1], [2,2], [1,3], [0,4] |
-------------------------------------- Lets splits things up between increase and decrease
| [4,1], [3,2], [2,3], [1,4] |
| [4,2], [3,3], [2,4] |
| [4,3], [3,4] |
| [4,4] |

R1 i start @ 0. As R += 1, i += 1. For each row, i -= 1. Once longest R is reached. First i always longest R. i -= 1 for every row.

The j col, j = j + 1 till len of row, reset = 0. Once it reaches max len, the start of j += 1 each time and j = j + 1. 

for i in range(len(mat)):
	append i number of times, append i -> 0
	clear()
		[0] | [1] [0] | [2] [1] [0] | [3] [2] [1] [0]

for j in range(len(mat)):
	append j number of times, append 0 -> i
	clear()

res_i, res_j = [], []
for i, j in range(len(mat)):
	for _ in range(i - 1, -1, -1):
		res_i.append(i)
	for _ in range(j):
		res_j.append(j)

What ends up happening here is that you have [i] [j] in seperate arrs. So you iterate through both at the same time and append val of the mat in res. The way I'm implementing it, we would not heave to clear.

res = []
for i,j in range len(res_i):
	res.append(mat[res_i[i], res_j[i]])

Ok. Lets just try to solve for this pattern: [0] | [1] [0] | [2] [1] [0] | [3] [2] [1] [0]

//Mar 27 2024
**Diagonal Traverse
lol this question is diabolical. You know that the dir of the traversal goes from 1 -> len(arr) before going back down to 9 again. 

Let try to understand the problem. Quiz Q 1: What is the sum of indices (i, j) for the top right elem of any matrix? 

**Plus One
Given int. Rep digits where digits[i] is ith digit of int. And you add one. 

1st method: turn arr into in, add, return the digits in arr format
val = int(for dig in digits n.join(''))
Wrong syntax, the correct method: 
num = int(''.join(map(str, digits))
return the val + 1 to arr
num = [int(dig) for dig in str(num)]
Ok for this method you have to convert the return digits back to string again. Not worth is.

Loop from the back. Add the last val. If the last val == 9, carry = 1, add one again. If there is a carry and you reach index 0, insert @ 0 index and shift everything back. Ok this is not the most run time optimal because of the insert at the start. Instead of inserting at the start, you could do [1] + [rest of arr] since its more run time efficent. 

for i in range(len(digits) - 1, -1, -1):
	if digits[i] < 9:
		digits[i] + 1
		return digits
	digits[i] = 0
	
	return [1] + digits

**Largest Number At Least Twice of Others
1) sort it
2) check if [-1] > 2 * [-2]

You have to return the index of the largest elem.
You only have to store 2 hashs 1) largest val + index 2) 2nd largest val and index. Loop through the arr using enumerate.

def dominantIndex(nums):
    l1, l2 = [float('-inf'), -1], [float('-inf'), -1]  # Initialize with -1 for indices
    for i, n in enumerate(nums):
        if n > l1[0]:
            l2[0], l2[1] = l1[0], l1[1]
            l1[0], l1[1] = n, i
        elif n > l2[0]:
            l2[0], l2[1] = n, i 
    
    if l1[0] >= 2 * l2[0]:
        return l1[1]
    else:
        return -1

More readable two pass approach:

max_val = max(nums)
max_index = nums.index(max_val)

for i, n in enumerate nums:
	if i != max_index and n * 2 > max_val:
		return -1

return max_index

One thing to note - you can find the index by simply calling nums.index(max_val) which I assume is also O(n)

Linked List questions are hurting me, so I'm going to move into arrays.

**Find Pivot Index
prefixsumR = prefixsumL

Q: what is the shortest method to write a prefix sum:

ls, rs, n = nums, nums, len(nums)
for i in range(1, n):
	ls[i] += ls[i - 1]
for i in range(n - 1, -1, -1):
	rs[i] += rs[i + 1]
	if rs[i] == ls[n - i]:
		return nums[n - i]
return -1

Ok, it seems like you overly complicated the heck out of this question. The most elegent method to solve it is to sum all the nums. Check for left sum. If left sum = total sum - left sum, return i, else return -1. 

sum_, ls = sum(nums), 0
for i, n enumerate(nums):
	return i if ls == sum - ls - n else ls += n
return -1

**Flatten a Mutilevel Doubly Linked List [Incomplete]
It seems like you're just putting the child list right after cur node. This is an insertion problem.

Loop through the linked list. If child, insert child and everything in the child layer between cur, and the next node. We can do this iterativly or recursivly. Lets try both methods.

With the iterative method:
cur = head
while cur:
	if cur.child:
		tmp_layer = cur.next
		cur = cur.child
		while cur.next:
			Q: what if there is another nested child?
	cur = cur.next

I'm pretty sure you NEED recursion to solve this. Because there could be up to n levels no?

For the iterative solution you need a 1) helper function 2) a maunal call stack to maintain. Seems pretty dumb to solve this problem this way.

Recursive solution:

What is the base case? If cur.next = None, return

if head is None:
	return
if head.child = None
	flatten(head.next)
else:
	flatten(head.next)

You have to relink to the next node @ the same level of cur before iterating through all the child though.

Base case + recursive step: The true base case is when cur.next and cur.child all == None. After you find a node with a child, you want to explore it completely. Recursively call on this function on the child node. flatten(cur.child). 

Relinking Nodes: You want to save cur.next somehow in the call stack before traversing the child. Seems like BFS with a queue like structure? Everytime you hit a child, you want to add to queue, and everytime that the call stack is complete, you dequeue the top layer (cur.next) and continue traversing cur.next.

Why is it that you don't have to check for a termination condition? I thought when solving linked lists problems recursively, you always have to return None or something if base case is hit. As for relinking nodes cur = cur.child.

if cur is None:
	return None

OK, I had to cheat for this portion. As I've guessed, you have a temp storage for cur.next. You need that to relink everything after you've traversed through all of the child nodes one layer down. Then you call flatten(cur.child). Ok the one thing I didn't think of is that you need to find the last child - that is the one you have to link back up with the higher level.

The process of relinking the nodes are 1) lastchild.next = tmp, tmp.prev = lastchild. That is if tmp though. I'm still a little confused even when given the code. So lets walk through the DFS step by step.

lastChildNode = cur.child
while lastChildNode.next:
    lastChildNode = lastChildNode.next

With this, you're iterating till you find the last child node in a level. This is how you know where to link the end of the child to the start of the top level. 

lastChildNode.next = next_temp
if next_temp:
    next_temp.prev = lastChildNode

This simply relinks the child level with the parent level.

**Add Two Numbers (Iterative)
Ok so it turns out that I did not need to reverse the nodes.

Correct code: You should initialize a dummy node. set cur as dummy so you can iterate over it. Also, you forgot to iterate prev1 and prev 2. Other than that its correct and you just return dummy.next.

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:
    c1, c2, prev1, prev2 = l1, l2, None, None
    while c1:
        c1.next, prev1, c1 = prev1, c1, c1.next
    while c2:
        c2.next, prev2, c2 = prev2, c2, c2.next

    dummy = ListNode(0)
    cur = dummy
    carry = 0
    while prev1 or prev2 or carry:
        val1 = prev1.val if prev1 else 0
        val2 = prev2.val if prev2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        cur.next = ListNode(total % 10)
        cur = cur.next

        if prev1:
            prev1 = prev1.next
        if prev2:
            prev2 = prev2.next

    return dummy.next

Draft code:

c1, c2, prev1, prev2 = l1, l2, None, None
while c1:
    c1.next, prev1, c1 = prev1, c1, c1.next
while c2:
    c2.next, prev2, c2 = prev2, c2, c2.next

carry = 0
while prev1 or prev2:
	val1 = prev1.val if prev1 else 0
	val2 = prev2.val if prev2 else 0
	sum = val1 + val2 + carry
	carry = sum // 10 
	val = sum % 10
	cur = ListNode(val) 
	cur = cur.next


//Mar 26 2024
**Add Two Numbers (Iterative)
The tricky thing about the iterative solution is that you have to look from R -> L and its a singly linked list. Is there a way to solve it in O(n) time and O(1) space. Is there a way to solve this problem without having to reverse the linked list?

1) Reverse the linked Lists

prev1, prev2, c1, c2 = None, None, l1.head, l2.head
while l1 or l2:
	c1.next, c2 = prev1, prev2
	prev1, prev2 = c1, c2
	c1, c2 = c1.next, c2.next

The problem with this code is that it does not handle the edge cases where the lists are shorter.

The proper method is:

c1, c2, prev1, prev2 = l1, l2, None, None

while c1 or c2:
	if c1:
		c1.next, prev1, c1 = prev1, c1, c1.next
	elif c2:
		c2.next, prev2, c2 = prev2, c2, c2.next
	elif not c1 and c2:
		c1.val, c1 = 0, c1.next
	else:
		c2.val, c1 = 0, c2.next

Ok, we'll handle the edge cases during the addition phase where sum = val1 + val2 + carry. 

c1, c2, prev1, prev2 = l1, l2, None, None
while c1:
    c1.next, prev1, c1 = prev1, c1, c1.next
while c2:
    c2.next, prev2, c2 = prev2, c2, c2.next

1) calculate sum
2) calculate carry
3) create and link new node from val
4) reverse nodes

while c1 or c2:

**Add Two Numbers (Recursive)
According to GPT, you need:

def addTwoNumbers(l1, l2, carry=0): The base case is if carry == 0 and not l1 and not l2. Then you return.

To handle the cases of if there is a val for diff len of linked lists, if l1 = 0 or if l2 = 0.

val1 = l1.val if l1 else 0
same with val2
sum = val1 + val2

carry = sum // 10
cur_val = sum % 10
cur_node = ListNode(cur.val)

recursive case:
next1 = l1.next if l1 else None
same w/ next2
cur_node.next = addTwoNumbers(nex1, next2, carry)


This questions suits recursion pretty well. The base case is if l1 and l2 = None. The recursive case, you want to pas l1, l2 and carry. 

if l1.val + l2.val > 10:
	addTwoNumbers(l1.val + l2.val - 10 ,1) #(sum, carry)
else:
	addTwoNumbers(l1.val + l2.val, 0)

Ok. What do yo make equal to addTwoNumbers? cur.next = addTwoNumbers? How do you handle the carry from a previous recursion?

The trivial solution is wrong - you did not read the questions properly- you're doing addition. The algo for the carry: either 1 or 0. num1 + num2, if > 10, -10 and carry = 1, else carry = 0. Since I'm lazy, I'm going to convert array to int, add, and convert to list again.

arr1, arr2 = [], []
while l1 or l2:
	if l1:
		arr1.append(l1.val)
		l1 = l1.next
	if l2:
		arr2.append(l2.val)
		l2 = l2.next

num1 = int("".join(str(n) for n in arr1))
num2 = int("".join(str(n) for n in arr2))

res = num1 + num2 
return [int(digit) for digit in str(num)]

The return expects a linked list, so just build one and return that

Trivial Solution

arr1, arr2 = [], []
while l1 or l2:
	if l1:
		arr1.append(l1.val)
		l1 = l1.next
	if l2:
		arr2.append(l2.val)
		l2 = l2.next

res = [0] * len(arr1)

for i in range(len(arr1)-1, -1 ,-1):
	res[-i-1] = arr1[i] + arr2[i]

return res

Ok. Did not read the problem correctly. There is a carry term.


**Merge Two Sorted Lists
Ok, lets try to use recursion to solve this. What is the base case? If not l1 or l2. What is the minimizing case? if l1 smaller, l2 = mergeTwoList(l1.next), else l1 = mergeTwoList(l2.next).

if l2 = None: 
	return l1
if l1 = None:
	return l2

if l1.val < l2.val:
	l2 = mergeTowLists(l1.next)
else:
	l1 = mergeTwoLists(l2.next)

First step is to create a dummy prehead node. Q: why is that helpful? This way we don't have to deal with the edge cases of 0 or 1 node in l1 or l2. The condition to decide whether the node from l1 or l2 should be attached to cur node is which is smaller. Compare l1.val to l2.val. Append the smaller one. cur.next = l1, l1 = l1.next. cur = cur.next to iterate. Once all the nodes are attached, you have two cases, where l1 = None or l2 = None. Take the one that is not None, and cur = l2/l1.next. Return head. 

dummy = newNode(None, next = head)
cur = dummy
while l1 and l2:
	if l1.val < l2.val:
		cur.next = l1
		l1 = l1.next
	else:
		cur.next = l2
		l2 = l2.next
	cur = cur.next

if l1 is not None:
	cur.next = l1
if l2 is not None: 
	cur.next = l2 

return dummy.next

The case that you missed is that you also have to return l1 and return l2 inside the case of l1.val <> l2.val. Why is that 

//Mar 25 2024
**Merge Two Sorted Lists
I remeber that there was a way to do it recursively and iterivly. Lets try solving it with a while loop first.

while l1 and l2, if l1 smaller, add that first, else add l2. when adding the flow looks something like (when comparing next vals). 

**Palindrome Linked List
Q: How do we do it in O(n) time and O(1) space? It seems like we would have to move 2 pointers at different speeds. The tricky part here is that its a uni-directional linked list.

1 -> 2 -> 3 -> 3 -> 2 -> 1

So using the fast and slow pointers you can find the midpoint. The tricky thing is how we do the comparisions.

1) you cant have a set, hash, or any other external storage 2) you can't create prev pointer (counts as extra storage) 

But you can reverse the linked list before the midpoint. Recall reversing a linked list:

cur.next = prev
prev = cur
cur = cur.next

count, cur, cur2, prev, f = 0, head, head, None, head
while f and f.next:
	count += 1
	cur = cur.next
	f = f.next.next

for _ in range(count//2):
	cur2.next = prev
	prev = cur2
	cur2 = cur.next

for _ in range(count//2):
	if cur2.val != cur.val:
		return False
	cur, cur2 = cur.next, cur2.next

return True

Few things to observe 1) Count is not needed. 2) You didn't handle the case of if not head or head.next.

if not head or not head.next:
	return True

s = f = head
prev = None

while f and f.next:
	f, s.next, prev, s = f.next.next, prev, s, s.next

if f:
	s = s.next

while prev and s:
	if prev.val != slow.val:
		return False
	prev, s = prev.next, s.next

return True

The most trivial method to do this is to traverse through the linked list and append each elem onto an array. Then you perform is Palindrome on the arry. for i in range(len(arr) // 2) and for j in range(len(arr)//2) is the same.

res, cur = [], head
while cur:
	res.append(cur.val)
	cur = cur.next

for i in range(len(res)//2):
	if res[i] != res[-i-1]:
		return False

return True

**Odd Even Linked List

You offset odd and even. Store where even started. Iterate while even and even.next. The key is you are not just iterating through via .next.next but rather you have to update the nodes with odd.next = odd.next.next, then move odd.

Ok, my main mistake is the fact that I traversed the linked list twice. No need for that. First and foremost, if there is no head, I should return None - that is the edge case. Set odd = head and even to be one offset. while there is even and even.next (since thats the longest node). Holy smokes, the idea of setting an evenHead is pretty smart. evenHead = even. 

Store all the odd vals and even vals. Then combine the linked list.

cur, odd = even = head
e, o = 0, 0
while odd.next:
	odd = odd.next.next
	o += 1
while even.next:
	even = even.next.next
	e += 1
for _ in range(e+o):
	cur = odd.next
	if odd.next == None:
		cur = even.next
return cur

Ok, you can't do odd.next.next. You have to start them offset by eachother.

**Remove Linked List Elements
Loop through the linked list. If val cur.val == val remove. Keep going till head == null.

You can look to see if cur.next.val == val. Since this is a singly linked list. we only really have to move one pointer.

cur.next = cur.next.next. We don't have to worry about two pointers. 

cur = head
while cur.next:
	if cur.next.val == val:
		cur.next = cur.next.next
	cur = cur.next
return head

Q1: My code would return 1 -> 2 -> 6 -> 4 -> 5 -> None? 
Q2: For Q2 you can check and modify the head pointer before the while loop, or easier yet, use a tmp dummy node

For the edge cases of these linked list, its good to have a dummy node:

dummy = ListNode(next=head)
cur = dummy
while cur.next:
	if cur.next.val == val:
		cur.next = cur.next.next
	else:
		cur = cur.next
	return dummy.next

//Mar 24 2024
**Reverse a linked
while loop. You have a tmp store. 

tmp = cur.next
cur.next = cur.prev
cur.prev = cur.next
cur = tmp

The elegent way to implement is cur, prev = head, None
while there is a cur, cur.next = prev, prev = cur, cur = cur.next. So what you wrote above was wrong.

**Intersection of Two LinkedLists
Most elegent version of the solution does not require counting. If any of the list elems are empty, return None. You set a and b to their respective heads. while a != b, you keep looping. 

a = a.next if a else headB
b = b.next if b else headA

Followup: write solution that is O(m+n) time and O(1) mem. So I cheated a bit and looked at the solution for O(1) space. You calculate the len of both arr and offset the len of the longer one by starting at len(long) - len(short).

a, b, len_a, len_b = headA, headB, 0, 0
while a:
	a = a.next
	len_a += 1
while b:
	b = b.next
	len_b += 1

if len_a > len_b:
	diff = len_a - len_b
	for _ in range(diff):
		a = a.next
	while a and b:
		a, b = a.next, b.next
		if a == b:
			return a

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a, b = headA, headB
        len_a, len_b = 0, 0

        # Calculate the length of list A
        while a:
            len_a += 1
            a = a.next

        # Calculate the length of list B
        while b:
            len_b += 1
            b = b.next

        # Reset pointers to the start of each list
        a, b = headA, headB

        # Adjust the starting point for the longer list
        if len_a > len_b:
            for _ in range(len_a - len_b):
                a = a.next
        else:
            for _ in range(len_b - len_a):
                b = b.next

        # Find the intersection
        while a != b:
            a = a.next
            b = b.next

        # Either both are None (no intersection) or both are at the intersection point
        return a

Can we not store the vals of a1 and b1 in a hash? If val in hash, return. 

a = headA
b = headB
a_list = set() 

while a.next:
	a_list.add(a)
	a = a.next

while b.next:
	if b in a_list:
		return b
	b = b.next 

return None

Corrected code: 

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a_nodes = set()

        # Traverse the first list and add all nodes to the set
        a = headA
        while a:
            a_nodes.add(a)
            a = a.next

        # Traverse the second list and check each node against the set
        b = headB
        while b:
            if b in a_nodes:
                return b  # Intersection found
            b = b.next

        return None  # No intersection

**Linked List Cyle II
Shortened version according to GPT. Cycle detection is still the same. The diff starts to happen while you're in the outer loop. if s == f. while head != s, you move head. 

s = f = head
while f and f.next:
	s, f = s.next, f.next.next

Code:
s = f = head
while f and f.next:
	f, s = f.next.next, s.next
	if s == f:
		break

cycle, ptr = 1, ptr.next
while ptr != s:
	ptr = ptr.next
	cycle += 1

ptr1 = ptr2 = head
for _ in range(cycle-1):
	ptr1, ptr2 = ptr1.next, ptr2.next
return ptr1

peudo code I:

step 1
c1, c2 = 0, -1
s = f = head
while f and f.next:
	f = f.next.next
	s = s.next
	c1 += 1
	if f == s:
		break
#observation, we don't even have to track c1 here

step 2
ptr = s.next
while ptr != s:
	ptr = ptr.next
	c2 += 1

step 3
ptr1 = ptr2 = head
while c2 >= 0:
	ptr2 = ptr2.next
	c2 -= 1
res = 0
while ptr1 != ptr2:
	ptr1 = ptr1.next
	ptr2 = ptr2.next
	res += 1
return res

The first thing we want to establish is that f can cross s at an 'arbitrary' location dependent on 1) where the cycle starts 2) the size of the cycle (number of nodes). This means if we can find 2) the size of the cycle, we can reverse engineer to where the cycle starts based on where they cross. 

Step 1:
To solve this, there is a couple of questions we have to answer 1) To detect if there is a cycle, we start both s and f at head, moving f 2x as fast as s. If s == f, there is a cycle. 

Step 2: 
To determine the size of the cycle you take the point where s == f. And s = s.next, fast = fast.next.next. Doing it with a cycle len of 4, (1,2,3,4 nodes) it seems like s moves 2x the length of the list before f catches up. So would the equation just be count s moved since s==f // 2?

step 3:
You just do count s==f location - size of cycle? 

Ok for step 2, you can just keep looping f till s == fast again and track the count. Ok, now the giga brain move is set up another ptr1 and ptr2. You move ptr1 by len of cycle at a time. ptr2 1 step at a time? '

You initalize ptr1 to be n steps ahead and iterate 1 @ a time. Q: why does this work? Since you know that one point is exactly n len further ahead, you know that pt1 will == pt2 in which its the start of the linked list.

Just to clearify for step 2 you start @ s == f, and you only iterate 1 ptr till you hit s==f again. And you simply count the number of increments?

Its the same as normal cycle detection, but you simply add an index counter no? There is the base case:

if not head or not head.next:
	return -1

f = s = head
p = 0
while f and fast.next:
	p += 1
	f = fast.next.next
	s = slow.next
	if f == s:
		return p
return -1

This does not work because the point in which f and s meet does not mean its where the cycle starts

Read into Two Pointer in LinkedList: To determine if cycle, you can use hash table or f and s pointer. 

Q: How would you do cycle detection and find the start of a cycle?

**Linked List Cycle
Pretty much, you move fast twice fast as slow. If fast == slow, return true, else return false. Q: what is the while condition? While fast.next.next and slow.next. 

**Design Linked List
def deleteAtIndex(self, index):
	if index == 0:
		self.head = self.head.next
		self.size -= 1
	elif index == self.size:
		self.tail = self.tail.prev
		self.size -= 1
	elif index > size:
		return -1
	else:
		cur = self.head
		while cur.next and index < size:
			cur = cur.next
			index -= 1
		cur.next.prev = cur.prev
		cur.prev.next = cur.next

Lets compare how my code is diff from GPTs. If index < 0 or index >= self.size return -1. Valid, this is a more general case. If index == 0, self.head = self.head.next. If self.head you also have to remove the tail that pointed back to the prev head. The other case is if there is no more head, then you set self.tail = None. If its at the end, there are two cases as well. -> wait no the other case where the list = empty just activates the condition above to remove head. self.tail = self.tail.prev, self.tail.next = None. You dont have to do while cur.next since its already managed by index. The key is that you do cur.prev.next = cur.next before cur.next.prev = cur.prev. 

The correct code: 

def deleteAtIndex(self, index):
    if index < 0 or index >= self.size:
        return -1
    elif index == 0:
        self.head = self.head.next
        if self.head:
            self.head.prev = None
        else:
            self.tail = None
    elif index == self.size - 1:
        self.tail = self.tail.prev
        self.tail.next = None
    else:
        cur = self.head
        while index > 0:
            cur = cur.next
            index -= 1
        cur.prev.next = cur.next
        cur.next.prev = cur.prev
    self.size -= 1
    return 0

//Mar 22 2024
**Design Linked List
Ok, lets first make a class called ListNode which should contain the def for node, and node val. I forgot the def. But I think you need something along the lines of 1) new node 2) node vals: 

class ListNode:
	def __init__(self, val):
		self.val = val
		self.prev = None
		self.next = None

For the above, its the inital initialization. For the MyLinkedList class, you want to define that the self.left. 

For the def of myLinkedList, it can vary a lot by if its a singly, or doublely linked list. Generally, for the node class you want to declare the val, prev and next. For the init for the MyLinkedList you would want to set the head, tail vals. 

One intresting thing you can also add is the size of the linked list. For example, if you constantly need to know the length of the list, instead of having to iterate through the list at O(n) time, you can look at the size attribute which is O(1). 

class MyListNode:
	def __init__(self):
		self.head = None
		self.tail = None
		self.size = 0

Ok, now for the def of add at head. There are two possible scenarios 1) its an empty linked list 2) its not a empty list.

1) If list, head = ListNode(val), tail = head, size = 1
2) Else head.prev = ListNode(val), head = head.prev, size += 1

def addAtHead(self, val):
	if not head:
		head = ListNode(val)
		tail = head
		size = 1
	else:
		tmp = head
		head.prev = ListNode(val)
		head = head.prev
		head.next = tmp
		size += 1

There is a few issues with how I wrote addAtHead. I mainly forgot to had self. Ok self = making changes to instance in python class. 

if not self.head:
	self.head = ListNode(val)
	self.tail = self.head
	self.size = 1
else:
     tmp = self.head
     self.head = ListNode(val)
     self.head.next = tmp
     tmp.prev = self.head
     self.size += 1

What I fogot was to make tmp.prev = self.head. I feel like there is a better name for tmp. maybe old_head.

Try to shorten:
self.head = ListNode(val) if not self.head else (self.head.prev = ListNode(val, self.head, None)

For the case of adding at tail, similar to adding at head, there are two cases: 1) adding tail to an empty arr 2) adding tail to an non empty arr. Question: how to add to the tail of an arr?

def addAtTail(self, val):
	if not self.tail:
		self.head = ListNode(val)
		self.tail = self.head 
		self.size = 1
	else:
        	self.tail.next = ListNode(val)
        	self.tail.next.prev = self.tail
        	self.tail = self.tail.next
        	self.size += 1

Another way to write the else case of addaAtHead:

else: 
	self.head.prev = ListNode(val)
	self.head.prev.next = self.head
	self.head = self.head.prev
	self.size += 1

  val <-> 1 <-> 2 <-> 3
   ^   
   h

def get(self, index):
	if index > self.size or index < 0:
		return -1
	cur = self.head
	while index > 0:
		cur = cur.next
		index -= 1
	return cur.val

def addAtIndex(self, index, val):
	if index > self.size or index < 0:
		return -1 
	elif index == size:
		addAtTail(val)
	elif index == 0:
		addAtHead(val)
	else:
		new_node = ListNode(val)
		cur = self.head
		while index > 0:
			cur = cur.next
			index -= 1
		new_node.next = cur.next
		new_node.prev = cur
		cur.next.prev = new_node
		cur.next = new_node
		self.size += 1

def deleteAtIndex
	
There are 4 links that you have to break. 

//Mar 21 2024
Started studying recursion
**Reverse String
Base case. When the string is empty, return res. Else keep returning reverseString(s[-1])

if not s:
	return res
res.append(reverseString(s[-1)])

The problem is that you have to declare res outside. And you need to create a helper function.

2nd try
res = [] 
def helper(s):
	if not s:
		return res
	helper(s.pop())

The problem with this helper code is that its simplying the index I want to remove. 

The solution that takes advantage of the call stack uses the following approach: The base case is if the index reaches len(s) // 2. That means you made every swap possible from the l and r side. The recursive case is s[i], s[-i-1] = s[-i-1], s[i]. Then you simply call the function iterating index + 1

def reverseString(s, i=0):
	if i >= len(s) // 2:
		return
	s[i], s[-i-1] = s[-i-1], s[i]
	reverseString(s, i+1)

**Squares of a Sorted Array
We are not allowed to 1) sort 2) square the elem. Take everything < 0, abs val it. reverse. nums1. nums2 = other half. loop through nums1 and nums2. Append to res in that order.

nums1, res = [], []
i = 0
while nums[i] < 0:
	nums1.append(nums[i]
	i += 1
nums1 = reversed(nums1)

k = 0
for j in range(i, len(nums)):
	while num[j] > nums1[k]:
		res.append(nums1[k])
		k+=1
	res.append(nums[j]
return res

Clean up mistakes:

def sortedSquares(nums):
    nums1, res = [], []
    i = 0
    while i < len(nums) and nums[i] < 0:
        nums1.append(abs(nums[i])**2)
        i += 1
    nums1 = list(reversed(nums1))

    k = 0
    for j in range(i, len(nums)):
        while k < len(nums1) and nums1[k] < nums[j]**2:
            res.append(nums1[k])
            k += 1
        res.append(nums[j]**2)

    while k < len(nums1):
        res.append(nums1[k])
        k += 1

    return res

**Find All Numbers Disappeared in an Array
There is a few edge cases to consider 1) if the skip num is at the start 2) if the skip num is at the end, 3) if there are repeats (not really a edge case to worry about). The question is if we can do it in O(n) time. Lets try the leetcode cheat sheet: https://leetcode.com/explore/interview/card/cheatsheets/720/resources/4725/

Arr is not sorted and its asking to find specific elems. The solution therefore uses a hashmap. Remeber you can only do O(n), but that does not mean you have to do only one pass.

Q: Does 1-n include numbers bigger than n in the input? Assume no.

Find len(nums). Turn that into a set. Loop through nums. If not in set, append to solution.

arr, res = set(), []
for i in range(len(nums)):
	arr.add(i)

for num in nums:
	if num not in arr:
		res.append(num)

return res

Ok that was pretty poo poo brained of you. You make nums a set, and check if its not in arr!

n = len(nums)
nums = set(nums)
res = []
for i in range(n):
	if i not in nums:
		res.append(i)
return res

Problem: You have to one index the arr. We fixed that by simply doing n+1 and not appending the 0th i elem.

//Mar 20 2024
**Third Maximum Number
O(n) solution means that we would not be able to sort. What if you maintain a res arr. For example res = [3rd largest, 2nd largest, largest]. Also we do not need a set.

for num in nums:
	if num > 3rd < 2nd, replace 3rd
	if nums > all, replace largest
	if nums > 2nd < largest, replace 3rd. 
	Else do nothing

res = [float('-inf')] * 3
for num in nums:
    if num > res[0] and num < res[2]:
        res[0] = num
    elif num > res[1] and num < res[2]:
        res[1] = num
    elif num > res[2]:
        res[2] = num
if len(res) >= 3:
    return res[0]
else:
    return res[-1]

The problem we face with this solution is that when comparing num < res[2] to neg inf, its always true. Therefore, you have to swap. Lets convience ourselves with an example: 

With [3,2,1], you get a res of [3, inf, inf]. Therefore you have to perform a swap everytime you add. Shift everything to the right in the new arr: 

res[0], res[1], res[2] = num, res[0], res[1]

//Mar 19 2024
**Move Zeros
You have a read and write pointer.

[0,1,0,3,12]
   r
 w 

If == 0, move r up and r, w = r, w, swapping the elems

[1,0,0,3,12]
   r
 w

Lets start with w = 0, r = 1

[0,1,0,3,12]
 w
   r

If nums[w] == 0, nums[r], nums[w] = nums[r], nums[w], w += 1, r += 1

[1,0,0,3,12]
   w
     r

[1,0,0,3,12]
     w
       r

swap

[1,0,3,0,12] -> This fails

The trick is to do it swap if its not 0. And if you do the swap, increment l. 


**Replace Elements with Greatest Element on Right Side
For these replace elem questions, you normally want to iterate from R -> L. Why? So you don't have to look foward and backtrack. The array is not sorted. for i in range(len(arr) - 1, - 1, -1). set num[-1] = -1. next val == max(cur, cur[i+1]

2nd last elem == max(cur, -1). Why not manually set arr[-2] = arr[-1], arr[-1] = -1

arr[-1] = -1
for i in range(len(arr)-2, -1, -1):
	arr[i] = max(arr[i+1], arr[i])
return arr

Input: [17,18,5,4,6,1]
Answer: [18,18,5,4,1,-1]
Expected: [18,6,6,6,1,-1]

Ok, you can't manually set arr[-2]. What if you just set arr[-1]? 
[17,18,5,4,6,-1]

for i in range(len(arr) -2, -1, -1):
	arr[i] = max(arr[i+1], arr[i])
arr[-1] = -1
return arr

It seems like they are shifting everything to the left by +1. I'm too brain dead - the new solution suggested by GPT is as follows. You set max_val = -1. And for i in range(len(arr)-1,...) tmp = cur val, set cur to max_val, and max_val is now = max(max_val, temp).

Q: Just for practice, can you solve this problem via swapping? #todo

**Valid Mountain Array
if cur always larger than prev (increse). Second there is decrease, only allow decrease. If increase again return false.

1) while increase, always increase

increase = True
for i in range(1, len(arr)):
	if arr[i] < arr[i+1] and increase: #this is the peak of the mountain
		increase = False
	if not increase and arr[i] > arr[i+1]:
		return False
return True

Try again while a while loop

i, downhill = 1, False
while arr[i] > arr[i-1]:
	i += 1
downhill = True
while arr[i] < arr[i-1]:
	i += 1
return i == len(arr)

**Check if N and Its Double Exist

It seems like you have to iterate two pointers i and j. Return true if: 1) i != j 2) i and j within arry bounds 3) the val of i == 2x that of j.

Make a set. If new val, add to set. If the val you see // 2 is in set with no reminders. Return true. Else return false.

dup = set()
for num in arr:
	if num % 2 == 0 and num // 2 in dup:
		return True
	elif num not in dup:
		dup.add(num)
return False

This code breaks here because it can only make a comparison to j after its's been added. A cheecky fix is to dup = set(arr). if num%2 == 0 and num // 2 in dup, return True. 

It broke with the following test case: [-2,0,10,-19,4,6,-8]. This fails because 0//2 and %2 == 0. Don't add 0 to set. One way is to never all 0s to the set. res_set = {x for x in arr if x! = 0}. You also have a if case for 0 zeros. Jank as hell. 

Visit the proper way to do it via deletions. 1) sort the reversed(sorted(arr)). Have i, j pointer. Move j by default. Move i if arr[j] * 2 < arr[i] i+= 1.

arr = reversed(sorted(arr))
while j < len(arr) - 1:
	if arr[j] * 2 == arr[i]:
		return True
	elif arr[j] * 2 < arr[i]:
		i += 1
	j += 1
return False


//Mar 18 2024

Count the # of zeros. Iterate backwords. This way you don't have to worry about shifting vals in the indexes.

[1,0,2,3,0,4,5,0]
               ^
You have a zero count which is 3 in this case. You hit the case of if i + zeros < n: which it fails. arr[i] == 0, so you -= 0. zeros = 2. You also go into the case of i + zeros < n which it fails. Do nothing.

[1,0,2,3,0,4,5,0]
             ^
zeros = 2... you keep moving left till arr[i+zeros] < len(arr). What about the case of case of zeros at the back of the index that we would not duplicate? Why are we counting those? I would assume that we would push elements out of the array. But we solve this problem by decrementing everytime we see an 0. For the array [1,2,0,3,0,4,0]
				  ^
i + zeros = 6 + 3 = 9 > len(arr). We then hit the case of arr[i] == 0: zero -= 1. i + zeros > n. Continue loop.

Merge Sorted Array

The cheating way to do it is to use extra space. declare nums3 = []. Loop through nums1 and nums2. Sort it. And for every i-th elem in num you set as nums1[i].

tmp = []
for num in nums1:
    tmp.append(num)
for num in nums2:
    tmp.append(num)
for i, num in enumerate(sorted(tmp)):
    nums1[i] = num

//Mar 16 2024

881 Boats to Save People

For the problem you want to sort the arr. You'll most likely run into the case where there is 1 boat per person because of the limit. You want to check if people[i] and people[i+1] <= limit. If yes, we move the pointer to +2, else + 1 and we increment the number of boats by one.

reversed(people.sorted())

Actually the order of the sort does not matter that much. 

i, boats = 0, 0
people.sort()
while i < len(people) - 2
	if people[i] + people[i + 1] <= limit:
		boats += 1
		i += 2
	else:
		boat += 1 
		i += 1
return boats

Refined code: 
        boats, i = 0, 0
        people.sort()
        while i < len(people):
            if i + 1 < len(people) and people[i] + people[i + 1] <= limit:
                boats += 1
                i += 2
            else:
                boats += 1
                i += 1
        return boats

#1,2,4,5

The code fails at the test case above. So we need two pointers L and R that converge towards the center. Recall even with the L and R pointer there is a case of += 2 boat and += 1 boat. If people [L] + people[R] < target. boats += 1, R += 1. If smaller than target boat += 2 L+= 1, R -=1

boats, L, R = 0, 0, len(people)
while L < R:
	if people[L] + people[R] < target:
		boat += 2
		L += 1
		R -= 1
	else:
		boat += 1
		R -= 1
return boats

We can simplify the expression more:
	if people[L] + people[R] <= limit:
		L += 1
	R -= 1
	boats +=1
return boats

This way we do not have to manually handle the +1 or +2 boat cases.
	
//Mar 6 2024
Answers:
1) The two different (parts?) of graphs are the vertices (nodes or values) and the edges (connect different nodes).

2) The most efficient way to represent a graph where the nodes are connected to a lot of other nodes is through adjacency lists. You can represent another node val by simply adding another char to the list.

3) Between DFS and BFS to find the shortest path of a unweighted graph, I would imagine you would want to use DFS. DFS, goes all the way to the end before trying again. The probability that you find a shortest path that way vs traversing slowing and equally in all directions is a lot higher sooner.

4) For depth first search you either use recursion or simulate the call stack using a stack.

Iterative:
stack = [first node]
while stack:
	for every node connected to first node:
		stack.append(connected nodes)
	cur = stack.pop()
	do something with cur

Recursive:
dfs(node):
	if node = null:
		return
	for every node connected to first node:
		cur = dfs(cur)

5) Shortest path finding for a map app? 

Correct Answers:
1) Directed vs undirected graphs
2) Dense graphs should use [?] if its unweighted, use a 2D boolean array. Why? Complexity = O(V^2)
3) For shortest path, BFS is more useful - Why? It guarantees the first time a node is reached

//Mar 7 2024
Q1: How would you iterate over each cell in the grind?
A1: In a grind there are rows(r) and columns (c). To traverse through the grid, [col][row]. The ways you can move are left ([c][r-1]), right ([c][r+1]), up ([c-1][r]), down ([c+1][r]).

GPT4 method to iterate:

for r in range(len(gird)):
	for c in range(len(grid[0])):
		#process cell grid[r][col]

Q2: Given a cell, how do you check if its land and start DFS from it?
A2: Oh I think I understand where this is going. Loop through the grid at O(n^2) till you find and island (1). Then you do DFS to mark all of the 1s in that insland as visited (maybe by changing 1 -> 0). And you have some external counter var for the # of islands. To answer your Q2:

if grid[r][c] == 1:
	dfs(grid[r + 1][c])
	dfs(grid[r - 1][c])
	dfs(grid[r][c + 1])
	dfs(grid[r][c - 1])

GPT4: The base case for DFS is 1) the bounds check 2) the land check. To check for bounds you do: 

1. if r < 0, r > len(gird), c < 0 or c > len(grid)
2. or grid[r][c] = '0'

Then you set the island to 0. 

Q3: How would you now describe handling the recursive DFS calls to ensure we fully explore each island?
A3: This recusrive call allows the function to navigate through the entire island by checking if there is any other peice of island around it in all directions. This applies to all the connected grid[r][c]. The only way for the recursion to end is if the call stack completes by hitting grid[r][c] == 0 or its out of bound, both meaning that the island ended.

Implement the DFS Function:

dfs(grid, r, c):
	if r < 0 or c < 0 or r > len(grid) or c > len(grid[r]) or grid[r][c] == 0:
		return

	islands += 1
	grid[r][c] = 0

	dfs(grid, r + 1, c)
	dfs(grid, r - 1, c)
	dfs(grid, r, c + 1)
	dfs(grid, r, c - 1)

Q4: Can you think of any optimizations or edge cases? 
A4: If the grind is all zero or 1, you can either return 0 or 1. However that will be O(n^2) no? I wonder if there is a more efficent way to handle these edge cases. 

1st attempt at writing func: 

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        islands = 0

        for r in range(len(grid)):
            for c in len(grid[r]):
                if grid[r][c] == 1:
                    dfs(grid, r, c)
                    islands += 1

        def dfs(grid, r, c):
            if r < 0 or c < 0 or r > len(grid) or c > len(grid[r]) or grid[r][c] == 0:
                return
            grid[r][c] = 0
            dfs(grid, r + 1, c)
            dfs(grid, r - 1, c)
            dfs(grid, r, c + 1)
            dfs(grid, r, c - 1)

        return islands

Problem #463

def islandPerimeter(self, grid: List[List[int]]) -> int:
	def dfs(grid, r, c, calls):
		if r < 0 or c < 0 or r > len(grid) or c > len(grid[r]) or grid[r][c] == 0:
			return calls += 1
		dfs(grid, r + 1, c, calls)
            	dfs(grid, r - 1, c, calls)
            	dfs(grid, r, c + 1, calls)
            	dfs(grid, r, c - 1, calls)
	
	for r in range(len(grid)):
		for c in len(grid[r]):
			if grid[r][c] == 1:
				dfs(r, c, 0)

#The key thing to realize is that the number of times that the island is touching water is simply the number of calls on the call stack

Max Area of Island: 
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        def dfs(r, c):
            if r<0 or c<0 or r>=ROWS or c>=COLS or grid[r][c] == 0:
                return 0
            grid[r][c] = 0
            area = 1
            area += dfs(r+1, c)
            area += dfs(r-1, c)
            area += dfs(r, c+1)
            area += dfs(r, c-1)
            return area

        maxArea = 0
        for r in range(ROWS):
            for c in range(COLS):
                if grid[r][c] == 1:
                    maxArea = max(maxArea,dfs(r, c))
        return maxArea      

Problem 994. Rotting Oranges:
def orangesRotting(self, grid: List[List[int]]) -> int:
	ROWS, COLS = len(grid), len(grid[0])
	def dfs(grid, r, c):
	if r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == 0 or grid[r][c] == 2:
		return
	grid[r][c] = 2
	dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)

	for r in range(ROWS): 
		for c in len(COLS):
			if grid[r][c] == 2:
				dfs(grid, r, c)

DFS does not work for rotting oranges as the uniform spread alone with the time tracking makes it easier to do BFS. 

To visit the next cell, add to queue, you loop through its neighbors, by [r+1][c], [r-1][c], [r][c+1], [r][c-1] and cur is simply queue.pop() checking if its == 0, 1, or 2. If its 2, spread the rot. += 1 to level. You set the 1s you visited to 2 to ensure you don't revisit. You keep repeating this while stack to ensure that all the oranges are rotten. The only conditions in which the stack is empty is 1) you reached every part of the grid 2) all the surroundings are either 2 or 0, meaning that there is no more oranges to rot.

form collections import deque
def prepareInitialQueue(grid):
	ROWS, COLS = len(grid), len(grid[0])
	rottenOrangesQueue = deque()

	for r in range(ROWS):
   		for c in range(COLS):
        		if grid[r][c] == 2:
				rottenOrangesQueue.append((r, c), 0)

	return rottenOrangesQueue


Mon Mar 11 2024

392. Is subsequence [SOLVED ON PLANE]

s_set, tmp = set(s), ''
for i in range(len(t)):
	if i in range(len):
		if t[i] in s_set:
			tmp += t[i]
if tmp == s:
	return True
else:
	return False

#Q, what if there are repeated letters in the subset - don't have to worry about it as it is a subsequence problem

334. Increasing Triplet Subsequence

#Recall that a greedy algo works for a problem where you can solve it by just solving
#the local optimum
#The first part to the problem is that you solve the sub problem of [i, j] and nums[i] #< nums[j]

#Q: what is the starting condition?

i, j, k = 0, 1, 2
while i < len(nums) - 2 and j < len(nums) -1 and k < len(nums):
	if nums[i] < nums[j] < nums[k]:
		return True
	elif nums[i] > nums[j]
		#iterate till you solve it


		i += 1
	elif nums[i] < nums[j] > nums[k]:
		j += 1
	else:
		k += 1
return False

Q what is the logic to iterate?

[1, 2, 3, 4, 5]
 i  j  k

In this example we return true

[2, 1, 5, 0, 4, 6]
 i
       j

                k

#The index condition will be taken care of the i, j, k loop
#you want to return False unless triplet found

#Another way to solve it- solve for the i j case first with a loop.
#Start another loop with k where 

i, j = 0, 1
while i < len(nums) - 2 and j < len(nums) - 1:
	if nums[i] > nums[j]:
		j += 1

Save vals

From now you can only iterate k 

We can actually rewrite that as

i, j = 0, 1
while j < len(nums) - 1:
	if nums[i] > nums[j]:
		j += 1
	else:
		break

k = j
while k < len(nums) - 1:
	if nums[j] > nums[k]
		k += 1
	else:
		return True
return True

Ok now lets try to break this. Imagine the test case: [5,4,3,1,2,3] -> this should return true @ for 1, 2, 3. However we're not moving i. So this fails. 

Q: how do you increment i? 

[5,4,3,1,2,2,8,1] -> This should return True
 i
     j

q: would it work if you save the min val that j has passed for i to index to?
if nums[i] > j_min:
	move i to j_min position

[5,4,3,1,2,2,8,1]
       i
         j


j_min = 1


1ST HALF CODE

i, j, j_min = 0, 1, nums[1]
while j < len(nums) - 1:
	if nums[i] > nums[j]
		j += 1
		j_min = min(j_min, nums[i])
		if nums[i] > j_min:
			i = j
	else:
		return True
return False

Now add the k index

-TODO...

March 12 2024

1171. Remove Zero Sum Consecutive Nodes from Linked List

You could use a while loop, although recursion is the most elegant solution. 

The first sub problem to solve: How to remove the consecutive elements:

if cur.val == cur.next.val: delete

Q: How do you delete two nodes at once?

[1, 2, -3, 3, 1]

Mar 13 2024

Ok let me walk you through what I am thinking. You have the vars i, j, k to track which indexes are able to return True. The starting condition has to be i, j, k = 0, 1, 2. The min possible val for nums[1] 

Next, the while loop of while j < len(nums) - 2 and k < len(nums) - 1: works because if j > len(nums)-2, or k = len(nums)-1, that means nums[i] < nums[j] < nums[k] and i < j < k would not be possible so we break it. Otherwise its fair game. 

Ok look at the line if nums[i] > nums[j]: That means we have to move j up to search for a j value that might fulfil nums[i] < nums[j] < nums[k]. We have to ensure that k > j. The mistake I made was j += 1 and k += 1 right away where I should've done if j = k, then k += 1. 

Now we need to keep j_min = min(j_min, nums[i]) because lets say in the example [5,4,3,1,2,2,8,1] we don't want to keep incrementing j till the end while i stays @5. Therefore if the j_min or a passed j value is smaller than i, we would want to move i there. Thus the code: 

                j_min = min(j_min, nums[i])
                if nums[i] > j_min:
                    i = j
                    j += 1


The problem with that is that you end up storing the lowest possible value. What you have to do instead is reset j_min and k_min at every cycle of the loop to the possible vals instead of the global min.

        while j < len(nums) - 2 and k < len(nums) - 1:
            j_min = nums[i]
            k_min = nums[j]

Ok now we add the k elem. Now we can repeat the logic for nums[j] > nums[k]. At the start of every loop, we set k_min = nums[j]. And then: 

            if nums[j] > nums[k]:
                k += 1
                k_min = min(k_min, nums[j])
                if nums[j] > k_min:
                    j = k
                    k += 1


Easy proof: if not nums[i] > nums[j] and not nums[j] > nums[k], that means nums[i] < nums[j] < nums[k] no? How can nums[i] be bigger than nums[k] if nums[i] < nums[j] and nums[j] < nums[k] for example? 

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        i, j, k = 0, 1, 2
        while j < len(nums) - 2 and k < len(nums) - 1:
            j_min = nums[i]
            k_min = nums[j]
            if nums[i] > nums[j]:
                j += 1
                if j == k:
                    k += 1
                j_min = min(j_min, nums[i])
                if nums[i] > j_min:
                    i = j
                    j += 1
            if nums[j] > nums[k]:
                k += 1
                k_min = min(k_min, nums[j])
                if nums[j] > k_min:
                    j = k
                    k += 1
            else:
                return True
        return False

[] TODO: FIGURE OUT WHAT IS WRONG WITH THIS ********

Q: to self-> why does this code not work? According to GPT:

To counter the dumb ass shit it said: 

1) j_min and k_min 

200 Number of Islands:
Do DFS on all the islands, set them to 0. # of islands += 1. Return # of islands

=> Input: Grid

ROW, COL = len(grid) - 1, len(grid[0]) - 1

#loop through the arry to find islan

num = 0

for r in ROW:
	for c in COL:
		if grid[r][c] == 1:
			dfs(grid, r, c)
			num += 1

dfs(grid, r, c):
	if r < ROW and c < COL and r >= 0 and c >= 0 and not grid[r][c]:
		return
	grid[r][c] = 0
	dfs(grid, r + 1, c)
	dfs(grid, r - 1, c)
	dfs(grid, r, c + 1)
	dfs(grid, r, c - 1)

return num

605 Can Place Flowers

input: flowerbed [], n int

#What you do is simply find the max number of flowers you should be able to plant

for i in range(len(flowerbed) - 1):
	if flowerbed[i] == 0 and flowerbead[i-1] == 0 and flowerbead[i+1] == 0
		count += 1

There are a few edge cases for first and last elem = 0 

[0, 0, 1, 0 , 0, 0, 1]
We can solve this by if flowerbed[0] and flowerbed[1] both == 0, += 1. Start on the 3rd index. 
For range(3, len(flowerbed) - 3)

Q; How about [...1, 0, 0] we can handle that case by only iterating till the 2nd last elem

Putting this all together:

count = 0

if flowerbead[0] == 0 and flowerbed[1] == 0:
	count += 1

if flowerbed[-1] == 0 and flowerbed[-2] == 0: 
	count += 1

for i in range(4, len(flowerbed) - 4):
	if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] == 0
		count += 1

return count >= n

Ok. For the edge cases, what you could do is just set the vals to 1. Edge case of len(1)?

Solved by having a case of len(flowerbed) == 0

238. Product of Array Except Self

[1,2,3,4] -> [24,12,8,6]

Try mutiplicative prefix sum:

[1, 2, 6, 24]   
[24,24,12,4 ]

Val * last val
[1,2,6,12]
[2,6,12,4]

The problem I ran into above is the fact that I did in inclusive

left_arr, right_arr, res = len(nums) * [1], len(nums) * [1], []

for i in range(1, len(nums)): 
	left_arr[i] = nums[i-1] * left[i-1]

for i in range(len(nums) - 2, -1, -1)
	right_arr[i] = nums[i+1] * left[i+1]

for i in range(len(nums)):
	res.append(left_arr[i] * right_arr[i])

930. Binary Subarrays With Sum

This is a sliding window problem with a binary sum. Lets pretend its not binary. How would you generally solve a sliding
window problem? 

LOL I thought it would be legit binary calculation. No we just counting the numbers of ones. We can do that with a prefix sum easily.

nums = [1,0,1,0,1], goal = 2
In this example the prefix sum
[1,1,2,2,3] if R - L + 1 = goal

Ok now that we figured out how to efficently calculate the sum of window elems lets make the sliding window

prefix = [num[0]]
for i in range(1, len(nums)):
	prefix.append(prefix[-1] + nums[i])

L, R, solutions = 0, 0, 0
while R < len(nums):
	if L == 0:
		if goal == prefix[R]:
			solutions += 1
			R += 1
	elif prefix[R] - prefix[L - 1] == goal:
		solutions += 1
		R += 1
	elif prefix[R] - prefix[L] + 1 < goal:
		R += 1
	else:
		L += 1

return solutions

The correct method to calcualte the prefix sum is actually [R] - [L-1]

Corrected version of the code according to GPT4: 

prefix = [0]
for nums in nums:
	prefix.append(prefix[-1] + num)

L, R, solutions = 0, 0, 0
while R < len(prefix) - 1: 
	cur_sum = prefix[R + 1] - prefix[L]
	
	if cur_sum == goal:
		solutions += 1
		R += 1
	elif cur_sum < goal:
		R += 1
	else: 
		L += 1

return solutions

This is a repeat of 930. Binary Subarrays With Sum

Q1: A sub array is a smaller portion of an array defined by a left and right bound. 
Q2: The naive way is to brute force at O(n^2). Have an i and j pointer. Iterate i by one and every time iterate j from i -> len(nums). 
Q3: Sliding window can be applied for this problem because we know that if a previous sub array overshot the target, ex [1,1,1,0] where target = 2, we know that we can skip over a portion of the arrays thus turning this to O(n^2).
Q4: Basic Sliding Window:

solutions == 0
l, r = 0, 0
while l < len(nums) - 1:
	if nums[l] + nums[r] == target:
		solutions += 1
		r += 1 #try to increase r, if its a 0, we can continue adding solutions
	elif nums[l] + nums[r] < target:
		r += 1 
	else:
		l += 1

One thing I'm thinking with this code is if we might be overshooting with R. Would we ever have l += 1 and then set r = l?

Q5: In the above code, you would increase l += 1 if sum nums[l] nums[r] > target to shrink the window 
Q6: If the sum of l and r == target, we can increase a counter.
Q7: One edge case that my code previously failed at is: [0,0,0,0,1,0,0,0,0] target == 0. I remeber failing a test case similar where the return val was 1 larger than it should've been. 

Ok. What is wrong with the current sliding window implementaion?

Q: how to we handle the case of sum == target? Brainstorming: 
1) Move right foward
2) mark l and r val as visited solution in set
3) try l -= 1, r += 1

The key is that we have to check if nums[l] + nums[r] == target repeat

while nums[l] + nums[r] == target:
	solutions += 1
	r += 1

Still not refined enough. Lets try to traverse through a prefix sum? Its not the most efficent

For the sliding window, if you're not using the prefix sum, you can +- the number 1s in the window by doing a check to see if nums[l], nums[r] == 0 or 1. You can keep a sum count this way at O(1) space and O(n) time complexity

pesudo code: 
solutions, window_sum = 0, 0
while l < len(nums)
	if wind_sum == target:
		solutions += 1
		r += 1
		window_sum += nums[r]
	elif window_sum < target:
		r += 1
		window_sum += nums[r]
	else:
		window_sum -= nums[l]
		l += 1

Refined version
l, r = 0, 0
window_sum = 0
solutions = 0

while r < len(nums): 
	window_sum += nums[r]
	
	while window_sum > target < 1 <= r:
		window_sum -= nums[l]
		l += 1

	if window_sum == target:
		solutions += 1
		tmp_l = 1
		while temp_l < r and nums[tmp_l] == 0:
			solutions += 1
			temp_1 += 1

735. Asteroid Collision

Pop from the stack twice. That will be the collisions. If same direction, append both to stack. If oppsite dir, append only the bigger one to the new stack. Q: do you continue till no more collisons? It seems like it. 

First step lets add to the stack:

stack = []
while asteroids:
	a1 = asteroids.pop()
	a2 = asteroids.pop()
	if (a1 > 0 and a2 > 0) or (a1 < 0 and a2 < 0):
		stack.append(a1)
		stack.append(a2)
	elif a1 > a2: 
		stack.append(a1)
	else:
		stack.append(a2)

Cool, now that we have this, how do we keep crashing them till? A: We should create a def func that we call till 1) empty 2) all > 0 3) all < 0

neg, pos = False, False
while stack or (not neg and pos) or (not pos and neg):
	for i in range(len(asteroids)):
		if neg and pos:
			neg, pos = False, False
			collide(asteroids)
		elif asteroids[i] > 0:
			pos = True
		else:
			neg = True

def collide(asteroids):
	stack = []
	while asteroids:
		a1 = asteroids.pop()
		a2 = asteroids.pop()
		if (a1 > 0 and a2 > 0) or (a1 < 0 and a2 < 0):
			stack.append(a1)
			stack.append(a2)
		elif a1 > a2: 
			stack.append(a1)
		else:
			stack.append(a2)
	return stack

Question: why do we not need another def function for this problem
Few assumptions: The collision logic is not complex enough to need to be abstracted out into its own function- it can all be handles in a while loop

stack = []
for asteriod in asteriods:
	collison = False
	while stack and asteriod < 0 < stack[-1]:
	
Ok so with         while stack and asteroid < 0 < stack[-1]: you're appending all of the neg val asteroid

Think about the base case. By default, there is no collision, you stack.append. Then there is the collision case: 
If we face an asteriod and the stack is not empty we check which one is bigger. The key here is to mark collision as True and break that while loop so we don't hit the case of if not collision, stack.append.

2126. Destroying Asteroids
The key to this problem is that you can sort the asteroids. That gives the planet the best chance because that max the size of the planet at every interval. Don't need stack. 

sorted(asteroids)

for asteroid in asteroids: 
	if mass > asteroid: 
		mass += asteroid
	else:
		return False
return True

739. Daily Temperatures

Use a stack. We're trying to map:
[73,74,75,71,69,72,76,73]  -> 
[1,1,4,2,1,1,0,0]

pop from the tempatures stack. Add to another tmp stack. I think the trick is how many times you have to pop from the tmp stack till you get a val that is larger.

stack = [tempatures.pop()]
res = []

while tempatures:
	count = 0
	tempature = tempatures.pop()
	while tempature > stack[-1]:
		stack.pop()
		count += 1
	res.append(count)
	stack.append(tempature)

Lets manually go through an interation: 

[73,74,75,71,69,72,76,73]
tempature =
count =
Stack =
Res =

This approach is not correct. Apprently you track the index of each day in the stack. 

If given a specific day's tmp, the most simple method is to iterative till next warmer tmp and count # of iterations. However, you could the index of the last highest tmp into the stack. And then to find number of days, you can do last higher index - cur index to find the number of days. 

You want to store the index val of the date.
Q: When do you add to stack?
Q: When do you pop from the stack?

Wait wtf is a monotonic stack?

Mar 15 2024

For a problem where you need to find the next greater element in array, why would you not want a regular stack? To be fair, I'm not sure how you would solve it efficiently with a regular stack. The brute force method to solve this is to iterate through i and make a comparsion to j every time which is O(n^2). Another way I wrote the other day for a similar question is to count the number of times a tmp stack gets popped(). This still seems O(n^2) as you would have to pop n elem, and add it again for the next iteration. What I'm thinking about is if there is a O(n) way to just count the number of pops. Perhapes making a set of the index + vals?

When you encounter an element greater than stacks top elem, I would guess that you keep popping until the last elem of the stack is larger? no idea lol. on 5 hours of sleep too tired to work it out myself (is that bad that I'm this lazy?)

Q: How does this provide O(n) run time? Recall for a monotonic stack, you only add the largest elem, and you keep popping from the stack till you 1) find an elem 2) there is no more elems in the arry. My knee jerk response is to count the number of pops. My but I recall that a problem stored the index elems. When you come upon the largest elem you find the diff between the index vals to find out how far they are apart from another. 
