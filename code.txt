//Apr 15 2024
**Reverse String**
We know how to do it using L R pointer, how do we do it using recursion. First and formost, the base case is if we reach the end.

Before that can we do s[::-1] - this does not work as we are not doing an in place manimpulation. 

With recursion questions, there is always 1) base case 2) reduction step 3) combining results. In the context of this problem, we have: 

def reverse_string(s):
	if len(s) <= 1:
		return s

	return reverse_string(s[1:]+s[0])

**Happy Number**
Determine if n is happy. For n to be happy 1) start with + int replace num by sum of sqaures of all digits. 2) Repeat till num == 1 3) If ends with 1 == 1 happy.

n = 19

Q: What is the ending condition? Goes through entire loop without returning one. You can detect a cycle by using a set.

numbers = set()

while n not in numbers:

Q: How do you split 19?

While 
n / 10  = 1
n % 10 = 9
R = 9

nvm, there is a python method to do it. num = 12345 
digits = [int[d] for d in str(num)]

while n not in numbers:
	squared_digits = [int[2]**2 for d in str[n]]
	n = sum(squared_digits)
	if n == 1:
		return True
	numbers.add(n)

return False

**Intersection of Two Arrays**
You take one. Make it a set. And iterate through the other arr and see if the elem occures in the set. If yes, append to res.

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = set() 
        dup = set(nums1)
        for num in nums2:
            if num in dup:
                res.add(num)
        return list(res)

**Contains Duplicate**
dup = set()
for num in range(len(nums)):
	if num in dup:
		return True
	dup.add(num)
return False

**Design Hashmap**
Ok, this question is pretty much the same as design hashset. The question that is top of mind is how do we associate a key to a value?

Brain is too fried, so I'm going to just use the answer that GPT gave to me:

class MyHashMap:
	def __init__(self):
		self.size = 1000
		self.buckets = [[] for _ in range(size)]

	def hash(self, key):
		return key % self.size

	def put(self, key, value):
		bucket_index = self.hash(key)
		bucket = self.buckets[bucket_index]
		for i, (k, v) in enumerate(bucket):
			if k == key:
				bucket[i] = (key, value)
			return 
		bucket.append((key, value))

Ok, lets go through this function together. First we have bucket_index which is just a call to the hash func. Once we find the bucket, we have touples: (key, value). When using the enumerate, we access 1) the index 2) the touple of (key, value). If k == key (accessed key value), bucket[i] == key. This handles the case where there is already a key and we are simply adding a new value. The other case is if there is no assoicated key in which case we append a key, value in the assoicated bucket.

bucket = [val1, val2, val3 ..etc]
buckets = [bucket1, bucket2, ..etc]

Now that we got that out of the way, let us try to write the get function by ourselves:

	def get(self, key) -> int:
		bucket_index = hash(key)
		bucket = buckets[bucket_index]
		for (k,v) in bucket: 
			if k == key:
				return bucket v
		return -1

Ok lets think about the structure of the bucket again. Each bucket contains a list of:

bucket = [(k1,v1), (k2,v2)...etc]

	def remove(self, key) -> None:
		bucket_index = hash(key)
		bucket = buckets[bucket_index]
		for i, (k,v) in enumerate(bucket):
			if k == key:
				bucket.remove((k,v)) #Figure out if this is correct syntax
				del bucket[i]
				return

Something to keep in mind is when you use the remove method, you don't have to do the enumerate through the bucket.

	for item in bucket:
		if item[0] == key:
			bucket,remove(item) 
			break

**Sum Root to Leaf Numbers**
class Solution:
    def sumNumbers(self, root):
        def allPaths(node, path, res):
            if not node:
                return

            # Add current node's value to the path
            path.append(str(node.val))

            # Check if it's a leaf node
            if not node.left and not node.right:
                # Join path into a number and add to results
                res.append(int(''.join(path)))
            else:
                # Continue to traverse the tree
                allPaths(node.left, path, res)
                allPaths(node.right, path, res)

            # Backtrack by removing the last node in the path
            path.pop()

        res = []
        allPaths(root, [], res)
        return sum(res)

**Binary Tree Paths**
Correct method cleaned up by chat GPT:

def all_paths(node, path, res):
	if not node:
		return
	
	path.append(str(node.val))

	if not node.left and not node.right:
		res.append('->'.join(path))
	else:
		all_paths(node.right, path, res) 
		all_paths(node.left, path, res)
	path.pop()
res = [] 
all_paths(root, [], res)
return res

We need to continue passing through path and res because we use those params to maintain the state through our functions. Also, we can pass [] as path because we don't need to return it outside of the all_paths func right? Lets say if we need to return the path in the outer function, then we would need to declare path = []. 

This is a sub problem to Sum Root to Leaf Numbers: 

def binaryTreePaths(self, root):

	def all_paths(node, path, res):
		if not node: 
			return
		
		path.append(node.val)

		if not node.left and not node.right:
			res.append(path.copy())
		else:
			all_paths(node.left, path, res)
			all_paths(node.right, path, res)
		path.pop()
	
	def format_res(res):
		if res.len(1):
			return str(res[0])
		for path in range(len(res)):
			for node in range(len(path)):
				res[path] += str(node) + '->'
		return res 
		
	res = []
	all_paths(root, [], res)
	format_res(res)

**Sum Root to Leaf Numbers**
Lets try to solve the all paths:

path = []

def all_paths(node, path, res):
	if not node:
		return 

	path.append(node.val)

	if not node.left and not node.right:
		res.append(path.copy())
	else:
		all_paths(node.left)
		all_paths(node.right)

	path.pop()
		
return res

Ok, so you want to append all the number as they were a string. And then add it. It seems like in order traversal is the method to go. root.val to str. while root, root.left, root.right. Append val to int onto a res arr. At the end, return sum(res). 

Recall that the method of an in order traversal is:

	res = []
	if root:
		traverse(root.left) 
		res.append(node.val)
		traverse(node.right)
	traverse (root)

For this, you want to do DFS tho. The DFS traversal algo explores the nodes and edges in a graph/tree before backtracking.

def dfs(node):
	if node is None:
		return

	res += (to_string(node.val))
	dfs(node.left) 
	dfs(node.right)
		
Q: Does this provide a DFS traversal of the entire tree?

If the tree looks like: 

    1
   / \
  2   3
 / \
4   5


The output would be 1,2,4,5,3. We need the following traversal:

1,2,4
1,2,5
1,3

You would actually need to do a different algo:

def all_paths(root):
	
	def dfs(node, path, res):
		if not node:
			return
		
		path.append(node.val)
		if node.left is None and node.right is None:
			res.append(path.copy())

The path.copy() creates a shallow copy of path list. Q: why do we need it? We need to create a copy for all possible path and we do not further modify the new version of path. 

Ok. Remeber the base case. Generally it is always return None. Once you hit the case of if there are no more paths, then create a copy. The other case is to traverse. At the end, there is a path.pop(). I wonder what that does. The pop removes the last elem in the call stack. This is just standard backtracking.

**Design Hashset**
There are a few methods for hashset. __init__, add, remove, contains. In the _init_. you're setting the hashset as an empty array. For the add function, if not self.contains(key): self.hashset.append(key). But it seems to me that the self.contains(key) is O(n) as you're traversing through the entire array to check to see if the key is there. Same with the def remove(key) -> None: if self.contains(key): self.hashset.remove(key). Which is also O(n).

Ok, lets do the shitty implementaion of the hashmap first: 

class MyHashSet:
	
	def __init__(self):
		self.hashset = []

	def add(self, key):
		if self.hashset not contains(key):
			self.hashset.append(key)

	def remove(self, key):
		if self.contains(key):
			self.hashset.remove(key)

	def contains(self, key) -> bool:
		if self.hashset.contains(key):
			return True
		return False

Lets walk through another (proper) method of implementing the hashset under the hood.

def __init__(self):
	self.size = 1000
	self.buckets = [[] for _ in range(self.size]]

Ok the code above allocates 1000 empty arrays or buckets. My question is, why not just do: 

self.buckets = []*1000 <- This does not work because it mutiplies and empty list by 1000. One thing you got to think about is what is the diff between a immutable and mutable object. And why is python designed in a way where nums = [0] * 100 = immutable and list = [[]] * 1000 = mutable.

Remember, when you are trying to generate a list of 1000 empty arrays, it is mutable (all the pointers reference the same mem location), therefore, you have to inialize it like:

def __init__(self):
	self.size() = 1000
	self.bucket = [[] for _ in range(size)]

def hash_function(self, key):
	return key % self.size

def add(self, key):
	bucket_index = self.hash_function(key)
	if key not in self.buckets[bucket_index]:
		self.buckets[bucket_index].append(key)

Ok, so what you're doing is creating a hash of the bucket_index. Then you are storing the val of the key into the bucket_index elem of the buckets array. The naming is kinda confusing. The key you are suppose to be able to retreive at O(1) along with assoicated val. 

With the add function, lets see the scenarios. 1) The bucket is empty, therefor, set the val to the hash 2) the bucket is full, then you have to chain. 

def remove(self, key):
	bucket_index = self.hash_function(key)
	if key in self.buckets[bucket_index]:
		self.buckets[bucket_index].remove(key)

At this point, it might be easier to defire bucket:

def remove(self, key): 
	bucket_index = self.hash_function(key)
	bucket = self.buckets[bucket_index]
	if key in bucket:
		bucket.remove(key)

def contains(self, key):
	bucket_index = hash_function(key)
	bucket = self.buckets[bucket_index]
	if kye in bucket: 
		return True
	return False

//Apr 14 2024
**Design Hashset**
You have to design a hashset with using any of the built in hash table libraries.
def __init__(self):
	hashset = []

def add(self, key) -> None: 

**Rotate Linked List**
Correct solution with optimizations:

if not head or not head.next or k == 0:
	return head

cur = head
size = 1
while cur.next:
	size += 1
	cur = cur.next
cur.next = head

k = k % size
new_tail = head
for _ in range(size - k):
	new_tail = new_tail.next
new_head = new_tail.next

new_tail.next = None

return new_head

Give the head of a linked list, roate the list right by k places.

Idea: Turn the linked list into a cycle. So connect the tail with the head. Track how long the linked list is. Move the head k times. That is the new head. From new head, move size of linked list times, and break the next. That is the new tail. Return the new head. 

size = 0
cur = head

while cur.next:
	size += 1
	cur = cur.next
cur.next = head

cur = head
for _ in range(k):
	cur = cur.next
new_head = cur 

cur = new_head
for _ in range(size): 
	cur = cur.next
cur.next = None

return new_head

There are a couple of things wrong with how I wrote my code. First and foremost my loop stops counting the size one node ealy because it checks for cur.next. The currect answer is while cur, or to add size +=1 at the end. Something else that is more of an optimization. Because rotating the list result in the same list, we should do k % size to minimize unessary rotations. That is a pretty big brained edge case that I did not think of. The fact that k can be larger than size. Finally, after determining the new head, we have to disconnect list properly.

The first case: 

if not head or not head.next or k == 0:
	return head

size = 1
cur = head

while cur:
	size += 1
	cur = cur.next
cur.next = head

k = k % size

new_head = head
for _ in range(size - k):
	new_head = new_head.next

new_tail = head
for _ in range(size - 1)
	new_tail = new_tail.next
new_tail.next = None

return return_head

Example k = 10, size = 4 10 % 4 = 2. This is then equal to 2 rotations + 2(complete rotations). Therefore size - k = 4 - 2 = 2. Total number of rotations we need to calculate.

Ok. So there seems to have been another error in my implementation. The key change is that after finding the new head, we have to immediately set the new_tail's next to None to break the cycle. We do not need the second loop. 

**Search in a Binary Search Tree** 
Ai ya. Yo do not need dfs for dis. Not doing this

def serachBST(root, val):
	def _dfs(root):
		if not root:
			return 
		if root.val == val:
			return True
		
		left_search = _dfs(root.left)
		right_search = _dfs(root.right)
		
	return left_serach or right_search

Oh its a binary search Tree: 

def searchBST(root, val):
    def _dfs(node):
        if not node:
            return False  # Return False if node is not found
        if node.val == val:
            return True  # Return True if the value matches
        elif val < node.val:
            return _dfs(node.left)  # Only search the left subtree if val is less than current node's value
        else:
            return _dfs(node.right)  # Only search the right subtree if val is greater than current node's value

    return _dfs(root)  # Start the search from the root

--Practice Graph Implementations--
**Design a graph using adjList**
Based off https://neetcode.io/problems/graph

class Graph:
	def __init__(self):
		self.adjList = {}

	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList: 
			self.adjList[dst] = set()
		self.adjList[src].add(dst)
	
	def removeEdge(self, src, dst) -> bool:
		if src or dst not in self.adjList: #ok, the syntax is wrong but right logic
			return False
		self.adjList[src].remove(dst)
		return True

	def hasPath(self, src, dst) -> bool:
		visted = set()
		return _dfs(src, dst, visited)

	def _dfs(self, src, dst, visited) -> bool:
		if src == dst: #This is the base case
			return True

		visted.add(src)
		
		for neighbor in self.adjList[src]:
			if neighbor not in visited:
				if self._dfs(neighbor, dst, visted):
					return True
		return False

	def _bfs(self, src, dst):
		visited = set()
		queue = deque()
		visted.add(src)
		queue.add(dst)

		while queue:
			cur = queue.popleft()
			if cur == dst: 
				return True

			for neighbor in adjList[cur]:
				if neighbor not in visited:
					visited.add(neighbor)
					queue.append(neighbor, dst)
		return False

**Rotten Oranges**
Correct code: 

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid:
            return -1

        R, C = len(grid), len(grid[0])
        rotten = deque()
        directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        res, oranges = 0, 0

        for r in range(R):
            for c in range(C):
                if grid[r][c] == 1: 
                    oranges += 1
                elif grid[r][c] == 2:
                    rotten.append([r, c])

        while rotten and oranges > 0:
            for _ in range(len(rotten)):
                x, y = rotten.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == 1:
                        grid[nx][ny] = 2
                        oranges -= 1
                        rotten.append((nx, ny))
            res += 1

        return res if oranges == 0 else -1

Remeber for rotten oranges, you use bfs, so a queue. 0 = empty, 1 = fresh, 2 = rotten. You can rot oranges by marking a 1 as a 2. One thing to remember is that you have to start the rot evenly. So there could be mutiple areas in which you start the rot. Remember, you hoave to count the total number of steps it takes the orange to rot. 

if not grid:
	return -1

R, C = len(grid), len(grid[0])
rotten = dequeu()
dir = [[1,0],[0,1],[-1,0],[0,-1]]
res = 0

for r in range(R):
	for c in range(C):
		if grid[r][c] == '2':
			rotten.append([r,c])

def bfs(loc):
	while queue:
		cur = queue.pop()
		res += 1
		for cur in dir:
			if cur[r][c] + dir[r][c] == '1':
				cur[r][c] + dir[r][c] == '2'
				rotten.append(cur[r][c] + dir[r][c])
			else:
				continue

return res

Ok, lets think through if this piece of code would in theory work. You go through the entire grid and check the total number of oranges. Ok. What if there is a chance that there is an orange you cannot reach? In that case, you return -1 as well. So we add: 

oranges = 0

for r in range(R):
	for c in range(C):
		if grid[r][c] == '2':
			rotten.append([r,c])
		elif grid[r][c] == '1':
			count += 1

When you infect an orange after: 

	cur[r][c] + dir[r][c] == '2'
	Add: 
	count -= 1

return res if count == 0 else return -1

**Island Perimeter**
You're counting the number of recusrive calls (number of times the 1 grid tries to expand but fail)

if not grid:
	return - 1

R, C = len(grid), len(grid[0])
res = 0

dfs(r,c):
	if r > R or c > C or r < 0 or c < 0 or grid[r][c] == 0:
		return 1
	if grid[r][c] == -1: 
		return 0
	grid[r][c] = '-1'
	dfs(r + 1, c)
	dfs(r - 1, c)
     	dfs(r, c + 1)
	dfs(r, c - 1)

for r in range(R):
	for c in range(C):
		if grid[r][c] == 1:
			res += dfs(r,c)

Something to to remeber is the fact that you want to do the addition of the perimeters within the dfs. You also want to mark visited as -1 instead of setting it as 0 to prevent recounting. 

Ok. You're code is mostly correct? There are some issues. First of all, the values should be 0,1,2. But you are using strings dumb dumb. Instead of pop, you should be using popleft (duh). Also also, cur is a coordinate, not a object. When updating the grid, you are doing ==. Finally you forgot to check to see if it falls out of grid space. 

//Apr 13 2024
--Practice Graph Implementation--

BFS Rotten Oranges: 

def orangesRotting(self, grid):
	if not grid:
		return -1
	
	R, C = len(grid), len(grid[0])	

	bfs(r,c): 
	
	for

DFS Number of islands: 

Remeber to mark the islands as visited by setting the 1s to 0 in the dfs function

def numIslands(self, grid):
	R, C = len(grid), len(grid[0])
	res = 0
	
	for r in range(R):
		for c in range(C):
			if grid[r][c] == 1:
				res += dfs(r,c,grid)

	def dfs(r,c,grid):
		if r < R and c < C and r >= 0 and c >= 0 and grid[r][c] == 1:
			grid[r][c] == 0
			dfs(r+1, c, grid)
			dfs(r-1, c, grid)
			dfs(r, c+1, grid)
			dfs(r, c-1, grid)
		return #good practice to put the base case at the start tho 

Correct ans:

def numIslands(self, grid):
	if not grid: 
		return 0
	
	R, C = len(grid), len(grid[0])
	res = 0
	
	def dfs(r, c):
		if r < R and c < C and r >= 0 and c >= 0 and grid[r][c] == 1:
			grid[r][c] = "0"
            	dfs(r + 1, c)
            	dfs(r - 1, c)
            	dfs(r, c + 1)
           	dfs(r, c - 1)
		return
	
	for r in range(R):
		for c in range(C):
			if grid[r][c] == '1':
				dfs(r,c)
				res +=1

	return res

	Ok dumb dumb. Just remeber to have the base case first. 

**Copy List with Random Pointer**
The key is to go through the list and make a copy with nodes points to random nodes. So each node has two pointers: 1) next 2) random. What you want to do is iterate through the list while cur. and cur = cur.next. If the random pointer points to an exisiting node, good, if not, create it and point to it. This is where we hit our first problem. If we already created a random val in the future, and we now have a cur.next that is suppose to point to it, how do we accomplish that? 

The assumption is that we cannot solve this question in a single run and we need extra O(n) space. You can solve the problem of figuring out the mappings of the random pointers by creating a hash map when going through the first run of the linked list. The key of the map can be the pointers of the orgional node, while the vals that we later look up is the the assoicated deep copy.

First thing is first, lets create a hash map:

hashmap = {}

Now let us iterate thorugh the orgional list, and create the deep copy of only the next vals while adding it to the hashmap. The sub problem to remeber here is to remeber how to create a new node. I'm going to ask GPT for the syntax. A: We can call the new_node = Node(5) keyword.

cur = head

while cur:
	copy_cur = Node(cur.val)
	hashmap[cur] = copy_cur
	cur = cur.next

That creates: 1 - 2 - 3- 4 - 5. But there is no connections. It seems like we have to make all the connections on the second iteration. So that means we have to save cur.next vals as well. We can use an array in the hashmap to store [next] and [random].

cur = head
while cur:
	copy_cur = Node(cur.val)
	hashmap[copy_cur]['next'] = cur.next
	hashmap[copy_cur]['random'] = cur.random
	cur = cur.next

What makes more sense? Using the old nodes as keys or the new nodes? I would imagine using the old nodes as keys. Also you don't have to do the hashmap[copy_cur]['next'] and hashmap[copy_cur]['random'] crap. You just need to store the vals of the nodes. 

cur2 = head
while cur2:
	hashmap[cur2].next = cur2.next
	hashmap[cur2].random = cur2.random

You want to save the head of the new deep copy. 

CODE:

cur = cur2 = head
hashmap = {}
new_head = Node(cur.val)

while cur:
	cur_copy = Node(cur.val)
	hashmap[cur] = copy_cur
	cur = cur.next

while cur2:
	hashmap[cur2].next = hashmap[cur2.next]
	hashmap[cur2].random = hahsmap[cur2.random]

return new_head

Ok, I needed to take a mental break here, so I handed the rest to chatGPT. 

I had a good start, but the proper method to do it is as follows: 

if not head:
	return None 

hashmap = {}

cur = head
while cur:
	copy_cur = Node(cur.val)
	hashmap[cur] = copy_cur
	cur = cur.next

cur = head #damn you dummy, I forgot that we had a reference to the orgional head node

while cur: 
	if cur.next:
		hashmap[cur].next = hashmap[cur.next]
	if cur.random: 
		hashmap[cur].random = hashmap[cur.random]
	cur = cur.next

return hashmap[head]

**Flatten a Multilevel Doubly Linked List**
Too lazy to write it correctly and think about all of the edge cases. The corrected version:

def flatten(self, head): 
	if not head: 
		return head

	cur = head
	while cur:
		if cur.child:
			child_tail = self.merge(cur, cur.child) 
			
			if cur.next: 
				child_tail.next = cur.next
				cur.next.prev = child_tail

			cur.next = child_tail 
			child_tail.prev = cur
			
			cur.child = None
		cur = cur.next
	return head

	def merge(self, parent, child): 
		current = child
		while current.next: 
			current = current.next
		return current

Ok, so it looks the the iterative solution might be better organized and easier to understand without the recursive overhead. For the primary flatten function, we iterate over the main list and look for nodes with children. When the node is found, you call the merge func. What the merge function does is locate the last node of the child list. Connect it to the main list node if it exists. Finally (you always seem to forget), you set the child pointer to None. 

def flatten(self, head):
	
	cur = head
	while cur or cur.child:
		if cur.child:
			child_tail = merge(cur.child)
			if cur.next: 
				cur.next.prev = child_tail
				child_tail.next = cur
			cur.next = child_tail
			child_tail.prev = cur.next
			cur.child = None

	def merge(node):
		while node:
			node = node.next
		return node

def flatten(self, head): 
	if not head: #return the end of the node
		return head

	def some other function to flatten():
	
You pass node in as a param.

if not node:
	return

next_node = node.next 

if node.child: #you traverse it and return the end of the child and connect that to the next of the next higher tree. 

	child_node = flatten_rec(node.child)
	
	#Then there is the case of if next or if child
	#Lets first work out the steps to reconnect the node

	#Link the cur node to the child node
	node.next = child_node
	child_node.prev = node
	
	if next_node:
		child_node.next = next_node
		next_node.prev = child_node

Ok, in the code above, the one thing you messed up is that when you reach the base case of the recursion, you get the tail. What you also want to store, is the actual val of the child node.

next_node = node.next
if node.child:
	child_tail = flatten_rec(node.child)
	
	node.next = node.child
	node.child.prev = node
	node.child = None 
	
	if next_node:
		child_tail.next = next_node
		next_node.prev = child_tail

	tail = flatten_rec(next_node) is next_node else child_tail
	return tail
else
	tail = flatten_rec(next_node)
	return tail if tail else node

We ran into a problem where we return an empty linked lists. I'm only returning the tail node of the flattened list @ the each step. So we have to come up with a method to return the head.

def flatten(self, node): 
	if not node:
		return None

	next_node = node.next
	
	if node.child:
		child_tail = self.flatten(node.child)
		
		node.next = child_tail
		child_tail.prev = node
		
		if node_next:
			node_next.prev = child_tail
			child_tail.next = node_next
		
		node.child = None
		
		return child_node
	
	else:
		return self.flatten(node_next)

Ok, this code throws a big fat error when you return child_tail when it == None. To fix this, you have to add if child_tail. 

GPT helped solution:

def flatten(self, node):
	if not node: 
		return None 
	
	next_node = node.next #ok that is a pretty big brain iterate through recursion instead of passing node.next as param 

	if node.child:
		child_tail = self.flatten(node.child)

	#Ok, here you have to convience youself that child_tail actually returns the tail of the child. 
	
---

def flatten(self, head):
	if not node:
		return
	if node.child:
		node.next.prev = flatten(node.child)
	flatten(node.next)
	
	return node

Ok, this is a first draft. The problem I'm thinking about is when we reach the end of the child, how do we reconnect the end of that lower level list back up to point to the next higher level. 	
Seems like you want recursion for this problem. What you are doing is moving to the next node till it has a child. If it does, you want to traverse through all of the child nodes. You end up connecting the end of the child node to the start of the original next node. Q: how do you best traverse this?

The first sub problem you have to solve is 1)How do you traverse a linked list recursively?

def traverse_list(node):
	if not node:
		return None
	traverse_list(node.next)

The advice that GPT gave is to also return the node. Which makes sense-> we need to know how to link the tree back together. 

To traverse to the child: 

if node.child:
	traverse_list(node.child)
travse_list(node.next)

So this will always traverse down to the child first. We also need to return the node up to the call stack at the end. Ok so now we have two options 1) build a new linked list (seems easier) 2) manipulate the pointers in place. 

Something else you want to consider is that you have to save a spot for the head pointer at the start and return it. 

The problem with the base case of None is the fact that we end up skipping the elems are after the child node. So we also need a method to add the next node. HOLY SHIT I got a big brain move. You simply when seeing a child node, save cur.next as well. This way you have a reference to next node on the higher level of the linked list, so you you are popping off the call stack, you can reconnect them then.

**Reverse Words in a String II**
1) We want to break up the arr. 
2) Iterate through the arr. 
3) For reverse each word in the arr in place
4) Return arr

s = s.split() 
for word in s:
	word = word[::-1]
return ' '.join(s)

The problem with this is that we are not modifying the orgional list s, instead assigning the a new var. 

**Reverse Words in a String**
Given input string s, reverse the order of the words. 

s.split(' ') to split the words into arr. The hard part is that you also have to remove extra spaces. The solution seems to be words = s.strip().split() but what does that do?

The .strip method in python is used to remove leading spaces sand trailing spaces. The. s.split method splits @ a specified char. If no params are given, it just splits @ whitespace. 

When you do .reversed(), you return the index not the words, so you have to ' '.join. So putting it all together. 

return ' '.join(reversed(s.split().split()))

**Pascal's Triangle II**
So given a rowIndex, return the row. We start each index from 0. It seems like you have a base case of first and 2nd row where you return [1] and [1,1] respectivly. Then, to generate cur row, cur_row = prev_row[i] + prev_row[i+1]. Recall to append a 1 before and after the loop. Outside, you simply have for i in range(rowIndex). 

res = [[1][1,1]]
for i in range(2, rowIndex):
	res[i].append(1)
	for j in range(len(res[-2])-1): #calculating cur row val
		res[-1].append(res[-2][j] + res[-2][j+1])
	res[-1].append(1)
return res[-1]

Correct ans:
	
**Remove K Digits**
This is apperently a Leetcode Hard, so I won't work on this just yet.

**Rotate Array**
nums = nums[k:] + nums[:k]

Ok apperently you have to do it in place. I'm thinking you have have a queue, and then popleft() and then then append. But that requires a new DS (queue) so its not in place. The O(n*k) solution is:

for i in range(k - 1):
	nums.append(nums.pop(0))

One way to solve the problem above is to use the slicing operation so that you dont have to create a copy of the OG arr. The pattern to notice is that you pop the last kth elem and append it to the front. So we can write it this way: 

nums[:] = nums[-k:] + nums[:-K]

Something else to consider is the fact that you have to handle cases where k is larger than arr size. You did not think of the edge case where k > len(nums). In that case, we just wrap around.

Going back, lets try to figure out what is wrong with the following answer: 

        for i in range(k):
            nums.append(nums.pop(0))

Ok, so the problem is apprently an 1 off error. My current code rotates k-1 time. So the Q: is why not just use for i in range(k+1)? Then it would rotate the arr +1 times than required. 

I'm still not sure what the main diff between:
	nums.append(nums.pop(0)) and nums.insert(0, nums.pop())

The diff between the two lies in which elem are being moved. 1) removes the first elem and moves it to the back 2) You move it to the begining

Holy shit, so the thing I've been doing wrong is inserting at the back rather than the start when rotation this arr.

Ok, we found two methods to do this. We can also do it with two pointers no? The trick is to take elems @ the back and move them to the front. This is kinda harder to do because you have to swap the pos of every elem to the right by k.

Ok. the question you have to figure out is if there is a O(n) time and O(1) space method using two pointers? A: possibly. Apprently there is also another trick where you do it using reversals. 

Ok, shot in the dark, you reverse the arr nums = [1,2,3,4,5,6,7], k = 3 to [7,6,5,4,3,2,1]. You popoff the last k elem and store them: [7,6,5,4] and [4,3,2,1]. Reverse them both and then add them to form [4,5,6,7,1,2,3,4]. 

Ok, so with the proper method, is a more explicit version of nums[:] = nums[-k:] + nums[:-k].

k = len(nums)
start = 0
end = k

while start < end: 
	nums[start], nums[end] = nums[end], nums[start]
	start += 1
	end -= 1

Ok, the big brained move is to 1) reverse the entire arr 2) reverse the first k elems 3)reverse the remaining n-k elem. Ok, lets think through why this would work. 

starting state: [1,2,3,4,5,6,7]
[7,6,5,4,3,2,1], now lets reverse the first k elem
[5,4,7,4,3,2,1] now k->n elem 
[5,4,7,1,2,3,4] This is the correct output

k = k % len(nums)
n = len(nums)

def reverse(start, end):
	while start < end:
		nums[start], nums[end] = nums[end], nums[start]
		start += 1
		end -= 1
reverse(0, n-1)
reverse(0, k-1)
reverse(k, n-1)

//Apr 9 2024
**Rotate Array**
return nums[:k] + num[k:][::-1]

**Min Size Subarray Sum**
This is a sliding window problem. Pretty much, if @ target, run the min(cur_min, global_min)
return 0 if global_min = float('inf')

        L, R = 0, len(nums) - 1
        _sum, global_min = 0, float('inf')
        for R in range(len(nums)):
            _sum += nums[R]
            while _sum >= target:
                global_min = min(R - L + 1, global_min)
                _sum -= nums[L]
                L += 1
        return global_min if global_min != float('inf') else 0
		
**Max Consecutive Ones**
Loop through it. Count max ones. if zero, cur ones = 0.

cur_ones, max_ones = 0, 0
for num in nums:
	if num == 1:
		cur_ones += 1
		max_ones = max(cur_ones, max_ones)
	else:
		cur_ones = 0
return max_ones

**Remove Element**
Given arra nums and int val, remove all vals in nums in place. Return # of elem in nums not equal to val.

Ok, if == val, move back. k+= 1, return nums.

k = 0
for i in range(len(nums) - 1):
	if num[i] != val:
		nums[i], nums[i+1] = nums[i+1], nums[i]
		k += 1
return k

Ok, I'm still kinda ass at in place manipulations. So it turns out the correct method to do it is: 

for i in range(len(nums)):
	if nums[i] != val:
		nums[i], nums[k] = nums[k], nums[i]
		k += 1
return k

**Two Sum II**
In a sorted arr, find two numbers such that they add up to target. Return the two index. 

        L, R = 0, len(numbers)-1
        while L < R:
            _sum = numbers[L] + numbers[R]
            if _sum == target: 
                return [L + 1, R + 1]
            elif _sum < target:
                L += 1
            else:
                R -= 1
        return [-1,-1]

**Array Partition I**
Given int arr and 2n ints, they pair up so the sum (a,b) for i is maxed. Return max sum. Are you not just returning the hightest and 2nd highest elem? You pair them largest to smallest.

Wait it to min. So you sort the arr. Start from L and R. The largest val * the smallest val.

res = 0
nums.sort()
L, R = 0, len(nums) -1
while L < R: 
	res += min(nums[L], nums[R])
	L += 1
	R -= 1
return res

Ok this is a dumb ass q. So it seems like you're trying to find the max val given that res += min(nums[L], nums[R]). You don't even need two pointers.

res = 0
nums.sort()
for i in range(len(nums)-1):
	res += min(nums[i], nums[i+1])
return res

Oops you have to increment i by two. You can do this by using the range function: i in range(0, len(nums)-1, 2).

**Reverse String**
L, R = 0, len(s) - 1
while L < R:
	s[L], s[R] = s[R], s[L]
return s

**Longest Common Prefix**
1) sort strs
2) start the first elem as prefix
3) if prefix != prefix of words prefix != [:len(prefix)-1]
4) prefix.pop()
5) retry. Then you reach the case where you return '' or prefix

strs.sort()
prefix = strs[0]
while not done: #change into proper conditional
	for str in strs:
		if prefix != str[:len(prefix)-1]:
			prefix.pop()
			break
	return res

Refined version:

if not strs:
	return ''

strs.sort()
prefix = strs[0]

If we decide to pop and empty string we'll have a one index error. The smarter method to do this is to have two loops like so:

for s in strs: 
	while not prefix == s[:len(prefix)]
		prefix = prefix[:-1]
		if not prefix:
			return ''
	return prefix

**Reveal Cards In Increasing Order**
Given deck where every card is unique. deck[i]. We can order deck however we want.

Input: [17,13,11,2,3,5,7]
Output: [2,13,3,11,5,17,7]

queue = deque(deck)
while queue:
	card = queue.popleft() #take the card from top
	queue.add(queue.popleft()) #next top at bottom

Return odering that would reveal cards in increasing order. Seems to me that you just build the arr. We dont want to add to the left since shifting the index is O(n) Q: can we use the len of the queue to calculate the index of there the elem should go?

res = [0] * len(deck)
queue = dequeu(deck) 
while queue:

Ok, what you want to do is sort the deck, and then simluate the reverse process with a queue. I think the key thing to notice is that if sorted maps to sorted queue and you run queue on it again, it maps back to sorted. I did not know that property of queues.

The boiler plate code for a qeue traversal: 

queue = dequeue()
arr = [...]
for elem in arr:
	if queue:
		queue.appendleft()

def deckRevealedIncreasing(deck):
	sorted_deck = sorted(deck, reverse = True)
	queue = deque() 

	for card in sorted_deck:
		if queue:
			queue.appendleft(queue.pop())
		queue.appendleft(card)

	return list(queue)


//Apr 8 2024
**Squares of Sorted Array** continued
The most elegent solution to this problem is if you leverage two pointers and merge directly without prechecking all pos or all neg.

N = len(nums)

We compute the index of the first non-neg numbers in nums list:

first_non_neg = next(i for i, x in enumerate(nums) if x >= 0, N)

The next expression finds the next index val.

#All postive
if nums[0] => 0:
	return [x**2 for x in nums]
#All negative
#Q: How do you map backwards from an array
if nums[-1] < 0:
	return [x**2 for x in nums][::-1]

L, R = 0, len(nums) - 1

while L <= R:
	M = (L + R) // 2
	if nums[M] >= 0 and nums[M - 1] < 0: #From the above checks, we know M > 1
		break
	elif nums[M] < 0: #can R side 
		L = M + 1
	else:
		R = M - 1

L, R = M - 1, M
res = []

while L >= 0 or R < len(nums):
    if L < 0 or (R < len(nums) and nums[R]**2 < nums[L]**2):
        res.append(nums[R]**2)
        R += 1
    else:
        res.append(nums[L]**2)
        L -= 1

return res

Q: How do you write an algo to expand outwards?
Start from M 1) while L and R pointer in bounds 2) whichever one is smaller, move and append to the new arr. 

Lets correct the code with feedback from GPT:

The all pos and neg edge cases are correct. To find the pivot elem, if M > 0 and nums[M] >= 0 and nums[M-1] < 0. Everything is the same except you add M > 0 so you dont get a out of bound error. 

You do M > 0 to not get M[-1]. But I still dont get it. How can there be a case of M == 0, if we checked that the arr must contain + and - vals? The min len must be 2, thus M at the min must be 1.

Ok, so the correct answer: 

if nums[0] >= 0: 
	return [x**2 for x in nums]
if nums[-1] <= 0:
	return [x**2 for x in nums][::-1]

L, R = 0, len(nums) - 1

while L <= R:
	M = (L + R) // 2
	
	if nums[M] < 0:
		L = M + 1
	else:
		if nums[M - 1] < 0:
			break
		R = M - 1

L, R = M - 1, M
res = []

while L >= 0 or R < len(nums):
    if L < 0 or (R < len(nums) and nums[R]**2 < nums[L]**2):
        res.append(nums[R]**2)
        R += 1
    else:
        res.append(nums[L]**2)
        L -= 1

return res

//Apr 7 2024
**Squares of Sorted Array**
Given sorted array of nums. Return the squares of each number sorted in non-decreasing order. The easy solution is to square everything and return sorted. Recall that map:

squared_numbers = [x**2 for x in numbers]
return sorted([x**2 for x in nums])

Another solution is to find the pivot elem using binary search. Use binary search to find the pivot (last neg val). From there split the nums arr at the pivot. Reverse the neg elems- but you still end up needing to sort it. 

Start from the pivot and append to a new res arr. Expand outwords.

[-4, -1, 0, 3, 10] -> [16, 1, 0, 3, 100]

When comparing, take the squared val. You need binary search for finding the pivot.

#All postive
if nums[0] => 0:
	return [x**2 for x in nums]
#All negative
#Q: How do you map backwards from an array
if nums[-1] < 0:
	return [x**2 for x in nums][::-1]

#Contains neg number case
L, R = 0, len(nums) - 1
while L <= R: 
	if nums[M]**2 

Followup question, is there a version of binary search for Large -> small -> Large again. 

**Find First and Last Position of Element in Sorted Array**
You are given a sorted array. Try to perform normal binary search till you find the target val? You want to continue doing binary serach till the L and R vals of target != target. Its almost as if you have ML, MR (mid left) and (mid right). 

[5,7,7,8,8,10]

L1, R2 = L1, R1 = 0, len(nums) - 1
while L1 <= R1 and L2 <= R2:
	M1, M2 = (L1 + R1) // 2, (L2 + R2) // 2
	if nums[M1] == target and nums[M2] == target and nums[M1-1] < target and nums[M2 + 1] > target:
		return [M1, M2]
	if nums[M1] < target:
		L1 = M1 + 1
	if nums[M2] < target:
		L2 = M2 + 1
	if nums[M1] > target:
		R1 = M1 - 1
	if nums[M2] > target: 
		R2 = M2 - 1
return [-1, -1]

Ok. The idea is umm.. and idea. But just use two seperate binary seraches.

res = [-1, -1]
L1, R1 = 0, len(nums) - 1
while L1 <= R1:
	M1 = (L1 + L2) // 2
	if nums[M1] == target:
		if M == 0 and nums[M1-1] < target:
			res[0] = M1
			break
		else:
			R1 = M - 1 
	if nums[M1] <= target:
		L1 = M1 + 1
	else:
		R1 = M1 - 1
[...] repeat with M2
return res if res[0] != -1 and if res[1] != -1 else return [-1, -1]

[5,7,7,8,8,10]
       M1 M2

From this you know that M2 >= M1 always. 

**Search in Rotated Sorted Array**
L, R = 0, len(nums) - 1
while L <= R: 
	M = (L + R) // 2
	if nums[M] == target:
		return M

	if nums[L] <= nums[M]:
		if nums[L] <= target < nums[M]:
			L = M - 1
		else: 
			R = M + 1
	else:
		if nums[M] < target <= nums[R]:
			R = M + 1
		else:
			L = M -1 1
	return - 1

Q&A Quiz w/ GPT 4: 
Q: Given arr of nums rotated on some unknown pivot. Ex [0,1,2,4,5,6,7] -> [4,5,6,7,0,1,2]. Find the target val in array. 
A: Do binary search till you find pivot elem. And then youre doing binary search two times. Once with the logic of if arr[M] < target: L = M + 1 (ascending), if arr[M] > target: L = M + 1 (desending)
GPT A: While my method could work, it is not the most efficent. The above method breaks down into two main steps 1) finding the pivot 2) perform standard binary search. However, this method requires two passes through the data. Q: How can we do it in one pass? You can roate the sorted arr with one pass, determining which side of the target falls within the sorted portion.

Q: Using binary search to find first occur of target where dups might exist. Return first index. 
A: else: while arr[L] == target, L -= 1. Return L. 
GPT A: A better approach that does not risk a O(n) loop looks at 1) if M > 0 and if arr[m-1] == target. R = m - 1. Return m. This way you're doing a 2nd binary search in the range of (last L -> m - 1). Smart!

Q: Scenario to lead me to L = M + 1 assuming (L + R) // 2
A: if arr[M] < target

**Single Element in a Sorted Array**
Given sorted array of ints, every elem appears twice, except one. Return the elem that only returns once. O(1) Space and O(logn) time. We can't sort it because it's O(1) space. Can we use XOR? Probably not since that seems like it only works for detecting doubles of a val. Wait no oops, we can use XOR to detect single val. 

res = 0
for num in nums:
	res ^= num 
return res

This is a O(n) solution with O(1) time.

We know that it will be some form for binary search. Lower bound = 1st elem upper bound = last elem. WTF is the shrinking condition? We don't know where the single val is located. You have to cut it base on even or odd length of arr. If contain single == odd, else even.

[3,3,7,7,10,11,11]
       ^
	  M 

L, R = 0, len(nums)

You have to look at [L] and [L + 1] are the same and (R + L) % 2 == 0. 

If we do M = (L + R) // 2 on the example above, we get (0 + 7) // 2 = 3 (since rounded). Once you get to the mid point, you want to make a L and R scan. If dup on the L side, you know the repeat # in on the right of the arr. Keep doing it till you hit the num.  

while L < R:
	M = (L + R) // 2
	if nums[M] == nums[M-1]:
		L = M + 1
	else:
		R = M - 1
return M

One thing we want to figure out for Binary Search Problems is when to return L, R, or M. A general rule of thumb is that you return L, when you're finding the first val that satisfies a certain condition. R for last occurance that satisfies condition. While the return M checks if the binary search has a exact match.

They did nums[M] == nums[M+1], L = M + 1. The operation flips the last bit of M. That seems to overcomplicate things. The other method is to simply do M % 2 == 1: M -= 1 to always ensure that M is even. 

Correct solution that I understand: 

def findSingle(nums):
    L, R = 0, len(nums) - 1

    while L < R:
        M = (L + R) // 2
        isEvenIndex = M % 2 == 0
        if (isEvenIndex and nums[M] == nums[M+1]) or (not isEvenIndex and nums[M] == nums[M-1]):
            L = M + 1
        else:
            R = M
    
    return nums[L]

**Sqrt(x)**
Binary search. Search space from (0->x).

while L <= R:
	M = (L + R) // 2
	if M * M < x:
		L = M + 1
	if M * M > x:
		R = M - 1
return M

I believe that the M, the answer, will be returned at the L == R case, in which the loop exits.

def mySqrt(x):
    L, R = 0, x
    while L <= R:
        M = (L + R) // 2
        if M * M < x:
            L = M + 1
        elif M * M > x:
            R = M - 1
        else:
            return M  # Perfect square case
    return R  # For non-perfect squares, R is the integer part of the sqrt

--Review AdjList Graph Design--

Example: 

{
    1: {2, 3},
    2: {4},
    3: {4},
    4: {1}
}

class graph:
	def __init__(self): 
		self.adjList = {}

	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList:
			self.adjList[dst] = set()
		self.adjList[src].add(dst)
		
	def removeEdge(self, src, dst) -> bool: 
		if src not in self.adjList or dst not in self.adjList:
			return False
		self.adjList[src].remove(dst)
		return True

	def hasPath(self, src, dst) -> bool:
		vistied = set()
		return _dfs(src, dst, vistied)
		return bfs(src, dst, visited)

	def _dfs(self, src, dst, visited) -> bool:
		if src == dst:
			return True
		if src not in visited:
			visted.add(src)
			for neighbor in adjList[src]:
				return _dfs(neighbor, dst, visited)
		return False

	Ok you fumbled the DFS.

	if src not in visted:
		visited.add(src)
		for neightbor in self.adjList[src]:
			if self.dfs(neighbor, dst, visited):
				return True
	return False

	def bfs(self, src, dst, visited) -> bool:
		vistied.add(src)
		queue = deque()
		queue.append(src)

		while queue:
			cur = queue.popleft()
			if cur = dst:
				return True
			visited.add(cur)
			for neighbors in self.adjList[cur]:
				if neighbor not in visited:	
					queue.append(neighbor)
					vistied.add(neighbor) 
		return False

//Apr 5-6 2024
**Valid Perfect Square**
The brute for binary search method. You start off with range(0->num). 

L, R = 0, nums
while L < R:
	M = (L + R) // 2
	if M * M < nums:
		L = M
	if M * M > nums:
		R = M
	if M * M == nums:
		return True 
return False

Correct solution: 

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        L, R = 0, num
        while L <= R:
            M = (L + R) // 2
            if M * M < num:
                L = M + 1
            elif M * M > num:
                R = M - 1
            else:
                return True
        return False

The key insight here is that L = M + 1 and R = M - 1 is generalizable to most binary search questions.

**Arranging Coins**
You have n coins and want to build a staircase with coins. Stairs have k rows where ith row have ith coins. 

Arr pattern: sum of coins:
[1,3,6,10,15,21] n
 1 2 3 4  5  6   R

21/6. Whats the formula that maps the R to n (number of coins?). The brute force method is to go through each row and do n+1 for each new row till we run out of coins to fill a row. Lets try that:

        row = 0
        while n >= 0:
            row += 1
            n -= row
        return row - 1

Now lets use binary search to solve this problem. Recall binary search is a method to cut the search space by 1/2 each time. Lets set the ceiling to n, and cut the search space by 1/2 each time. How do we go from R -> n?

If we think about it geometrically, the staircase is 1/2 a square. So to get n from row we can do:

n = ((r * r + r) // 2)

Rearrange

n * 2 = r*r + r
n * 2 = r(r+1)
We can use ax^2 + bx + c = 0

The solution for r = (-1 + (1 + 8 * n) ** 0.5) / 2. You can just floor that for the solution. 

Also remeber that the formula for arthemtic sum = m + m + 1 // 2
--Review of AdjLit BFS, DFS, Desgin--

Lets start with the design of a graph:

class graph:
	def __init__(self):
		self.adjList = {}
	
Ok Q: What does the __init__ method actually do in this context? Guess, it inialzies the adjList to a empty hashmap. And the self.adjList simply means that there could be mutiple instances of the same adjList object. 

Ok, update in knowledge: __init__ is a constuctor which is auto created when new instance of class is made. The word self signifies that the method belongs to cur instance of class meaning each instance of graph can have own seperate adjList ditc. 

	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList:
			self.adjList[dst] = set()
		self.adjList[src].add(dst)

	def removeEdge(self, src, dst) -> bool:
		if src not in self.adjList[src] or dst not in self.adjList[dst]:
			return False
		self.adjList[src].remove(dst)
		return True

	def hasPath(self, src, dst) -> bool:
		vistied = set()
		return self._dfs(src, dst, vistied)

I noticed that when you call another function within the func def such as ins hasPath, you dont have to manually add self as a param? Ex return _dfs(src, dst, vistied). This is because when calling another method from the same class, the self is implicity passed as the first param by python.

	def _dfs(self, src, dst, visisted)-> bool:
		if src == dst:
			return True
		
		if src not in visited:
			for neighbor in self.adjList.get(src, []): #we dont have to format it like that
				visited.add(neighbor)
				if self._dfs(neighbor, dst, vistied):
					return True
		return False

Try again in the afternoon:
	
	def _dfs(self, src, dst, visited) -> bool:
		if src == dst:
			return True

		if src not in visted:
			visted.add(src)
			for neighbor in adjList[src]:
				if _dfs(neighbor, dst, visited):
					return True
		return False

Ok, there might be still some small problems with my implementaion: The biggest being that we do not mark visited within the for loop. By doing that, it means we prematurely, mark the nodes as visited. its not like it will always fail, but it will add un-needed complexity.

Aight, let us try with BFS. Remeber for bfs, you need to have a queue, and you keep popping off level by level.

	def _bfs(self, src, dst, visited) -> bool:
		queue = deqeue()
		queue.add(src)
		visited.add(src)
		while queue: 
			for _ in range(len(queue))
				cur = queue.popleft()
				if cur.val == target:
					return True
				for neighbor in AdjList[cur]:
					if neightbor not in visted:
						queue.append(neighbor)
						visted.add(neightbor)
		return False

A few corrections:
1) for queue you do append instead of add- its not a set
2) you dont do cur.val, you look right at cur. 
					
Example: 

{
    1: {2, 3},


    2: {4},
    3: {4},
    4: {1}
}

**Minimum Size Subarrary Sum
Return min length of subarray that sum is greater or equal to target. Else return 0. This is a sliding window problem. You start off with a left pointer and a right pointer @ 0. L pointer shrinks the window (while sum of sub array >= target, shrink left, subtract l val 
from sub array), else, R++ (we can just do that in a for loop). return length.

I read the question wrong the first time. 

L, total = 0, 0
length, min = 0, float('inf')
for R in range(len(nums)):
	total += num[R]
	length += 1
	while total >= target:
		min_length = min(length, min_length) 
		L += 1
		total -= nums[L]
		length -= 1
return min_length if min_length != float('inf') else min_length

Corrected code: 

L, total = 0, 0
length, min_length = 0, float('inf')
for R in range(len(nums)):
    total += nums[R]  # Corrected typo here
    length += 1
    while total >= target:
        min_length = min(length, min_length) 
        total -= nums[L]  # Subtract the current L, then increment
        L += 1
        length -= 1
return 0 if min_length == float('inf') else min_length

**Find All Duplicates in an Array
Ok the big brained solution to this is that you mark the indexs you visted by making it -. And the visit goes to the index of the val. [3,2,2,4], the first index marks 4 neg. And by traversing the abs vals of the arr.

res = []
for num in nums:
	index = abs(num) - 1
	if nums[index] < 0:
		res.append(num + 1)
	else: #mark as -
		nums[index] = -nums[index]
return res

Given nums 1-n where each int appears once. Return a arr where intergers appear twice. There is the hash set solution which is O(n) time and O(n) space. 

dup, res = set(), []
for num in nums:
	if num not in dup:
		dup.add(num)
	else:
		res.append(num)
return res

Ok. Now how do we do it without a hash set? We cant sort it because it uses O(n) can we use the XOR operation? Everythime its 0, we append the res?

res = []
for num in nums:
	
Nope. The XOR method seems to only work for one repeat val due to the cummalitive property.

--Design Graph--
Example of the list: 

{
    1: {2, 3},
    2: {4},
    3: {4},
    4: {1}
}

Keep in mind whn we are doing if src not in self.adjList or dst not in self.adjList, we are looking at the keys not the vals of the keys.

class Graph:
	def __init__(self)
		self.adjList = {}
	
	def addEdge(self, src, dst):
		if src not in self.adjList:
			self.adjList[src] = set()
		if dst not in self.adjList:
			self.adjList[dst] = set()
		self.adjList[src].add(dst)

	def removeEdge(self, src, dst):
		if src not in self.adjList or dst not in self.adjList:
			return False
		self.adjList[src].remove(dst)
		return True
	
	def hasPath(self, src, dst): #this is just DFS no?
		visited = set()
		return self._dfs(src, dst, visited)

	def _dfs(self, src, dst, visited):
		if src == dst:
			return True
		visited.add(src)
		for neighbor in self.adjList.get(src, []):
			if neighbor not in visited:
				if self._dfs(neightbor, dst, visited):
					return True
		return False

**Single Number
I completely forgot about XOR operations. What you do is set res = 0, and for num in nums, res ^= num. 

[4,1,2,1,2]
res ^= 4 = 0 ^= 4 = 4
4 ^= 1   = 0

Ok, XOR happens at the binary level. Some useful proofs are: A number XORed with itself = 0. A number XORed with 0 is the number itself. XOR is commulative and associative. This means that the order of XOR operations dont matter. 

DFS(node, target, adjList, visited):
	if not node:
		return 0
	if node.val == target:
		return 1

	count += 1
	visited.add(node)
	for neighbor in adjList[node]:
		count += dfs(node, target, adjList, visited)
	visted.remove(node)
	return count

def BFS(node, adjList, target):
	visited = set()
	visited.add(node)
	queue = deque()
	queue.add(node)
	length = 0
	
	while queue:
		for _ in range(length(queue)): 
			cur = queue.popleft()
			if cur.val == target:
				return length
			for neighbor in adjList[cur]:
				if neighbor not in visited:
					visited.append(neighbor)
					queue.add(neighbor)
			length += 1
	return length

//Apr 4 2024
**Clone Graph
It seems to me that if you want to make a deep copy of a graph given an reference node + adjacency list you want to do a BFS traversal. And if the new node is not copied, copy it to the new graph. BFT works best because it ensures that we connect every edge to every node, where we would have to manually backtrack for DFS.

Given that you written BFS earlier, what is the major diff here I'm thinking.

1) You have to make new nodes and copy the vals of each

--DFS, BFS practice --- 

Practicing traversals using adjacency lists. To initalize, you want a source and destination. 

class GraphNode: 
	def __init__(self, val):
		self.val = val
		self.neighbors = [] 

You could also use a hashmap:

adList = {'a':[], 'b':[]}. Example, given edges:
edges = [["A", "B"], ["B", "C"], ["B", "E"], ["C", "E"], ["E", "D"]]

build and adList:

for src, dst in edges:
	if src not in adList:
		adList[src] = []
	if dst not in adList:
		adList[dst] = []
	adjList[src].append(dst)

DFS to count paths to a target using back tracking:

visit = ()
def dfs(node, target, adList, visit):
	if node in visit:
		return 0
	if node == target:
		return 1

	count = 0
	vist.add(node)
	for neighbors in adList[node]:
		conut += dfs(node, target, adList, visit)
	vist.remove(node)

	return count

BFS to find shortest path to target:

def BFS(node, target, adjList):
	length = 0
	visit = set()
	visit.add(node)
	queue = deque()
	queue.append(node)

	while queue:
		for i in range(len(queue)):
			cur = queue.popleft()
			if cur == target:
				return length
			
			for neighbors in adjList[cur]:
				if neighbot not in vist:
					vist.add(neighbor)
					queue.append(neighbor)
			length +=1
	return length		


Try again:

adList = {'a':[], 'b':[]}
cur = 'a':[]

def BFS(node, target, adjList):
	queue = deque()
	queue.add(node)
	visit = set()
	visit.add(node)
	length = 0

	while queue:
		for i in range(len(queue))
			cur = queue.popleft()
			if cur.val == target:
				return length
			for neighbor in adjList[cur]:
				if neighbor not in visit:
					visit.add(neighbor)
					queue.append(neighbor)
		length += 1
	return length
			
**Unique Number of Occurrences
Given a arr of int. Return true if # of occurrences of each val is unique. Create a hash map: key = num -> val = # of num occurence. Loop through the vals, add to set, if in set, return False, else return True.

numCount, occurance = {}, set()
for num in range(len(arr)):
	if num not in numCount:
		numCount[num] = 1
	else:
		numCount[num] += 1

for val in numCount.values():
	if in occurance:
		return False
	else:
		occurance.add(val)

return True

**Max Consecutive Ones III
You are able to flip k bits. Find the total number of consq ones you can make. Q: where would the prefix sum be useful here? 

You do prefix sum. You have to make sure that index R - L + k == sum(r) - sum(l). You keep a running total of the max (R - L + k).

0,1,1,0,1
0,1,2,2,3

1st lets create a prefix sum. 

prefixSum = nums[1]
for i in range(1, len(nums)):
	prefixSum.append(num[i-1] + prefixSum[-1])

L, R = 0, 1

R you move by default. You only move L if you cannot create a consecutive one. You cant do L += 1 since it will be O(n^2). Can you move L -> R?

[1,1,1,0,0,0,1,1,1,1,0]
 l     r       

Had to search to to move l pointer to shrink the window in this sliding window q. We have to move l += 1 i think. And we don't have to calculate the sum of in between L <-> R @ O(n) time each time. So in total the time complexity is O(N).

If condition meet, r += 1, else while condition not meet l += 1. Track largestConsecutive. 

while R < len(nums):
	if R - L < prefixSum[R] - prefixSum[L] + k:
		largestConsecutive = max(largestConsecutive, prefixSum[R] - prefixSum[L] + k)
		R += 1
	else:
		L += 1

return largestConsecutive

Ok. Remeber, we only use prefix sum when we need to calculate the sum of elems in a range. We're not doing that here. 

onesUsed = k
while R < len(nums):
	if nums[R] == 0:
		oneUsed -= 1
		if oneUsed == 0: #shrink window
	R += 1

Ok, you need to practice your boiler plate code for sliding window problems:
There are two types of sliding windows 1) fixed size:

for r in range(len(nums)):
	if r - l + 1 > k:
		window.remove(nums[L])
		L += 1
	else nums[R] in window:
		return True
	window.add(nums[R])
return False

And then, there is var size:

for R in range(len(nums)):
	total += nums[R]
	while total >= target:
		length = min(R-L+1, length)
		total -= nums[L]
		L += 1
return 0 if length == float('inf') else length

So this is a sliding window problem. How would you solve it?

L, total = 0, 0
length = -float('inf')

for R in range(len(nums)):
	total += nums[R]
	while length < total + k:
		
#how do we shrink the window? while sums not consecutive. total += nums[R]. while total + k > R - L:
	length = max(R - L + 1, length)
	length -= nums[L]
	L += 1

L, total, length = 0, 0, 0
for R in range(len(nums)):
	total += nums[R]

	while R - L + 1 > total + k:
		total -= nums[L]
		L += 1

	length = max(R - L + 1, length)
return length


**Delete the Middle Node of a Linked List
Have a f and s pointer. Where f moves 2x s. delete @ s once f reaches end. For the base case of n = 1, delete first node. 

s = f = head
if not s.next:
	return None

if not s.next.next:
	return head.next

while f and f.next:
	s, f = s.next, f.next.next

return head

Proper solution: Handle 0 or 1 case: 

if not head or not head.next:
	return None

if not head.next.next: 
	head.next = None
	return Head

s = f = head
while f and f.next
	s, f = s.next, f.next.next
s.next = s.next.next

return head

1 3 4 7 1 2 6
      s
            f

You have to stop at s.prev

prev = s.next

if not head or not head.next:
	return None

s = f = head
prev = None

while f and f.next:
	prev, s, f = s, s.next, f.next.next

prev.next = slow.next
return head

//Apr 3 2024
**Longest Common Prefix
Sort. The prefix starts out as the shortest val. For each elem in inputs, compare to prefix. If val !=, reduce prefix size. Return prefix size or ''. We don't have to have a case for that.

strs.sorted()
pre = strs[0]
reduce = 0
for i in range(len(strs)):
	for j in range(len(pre - reduce)):
		if pre[j] != strs[j]:
			reduce += 1
return pre[:j]

Corrected code:

return '' if not strs

strs.sort()
pre, red = strs[0], 0

for i in range(1, len(strs)):
	for j in range(len(

**Implement strStr()
Learning about the KMP algo: The naive approach restarts the comparsion from next char of text everytime there is a mis match (this the m*n runtime). You want to build a prefix table (LPS Array). This also stands for longest proper prefix. You build it by setting an empty lsp == len of needle. 

Example for Prefix Table:
Pattern: "ABCDABD"
LPS Array: [0, 0, 0, 0, 1, 2, 0]

if set(needle) in set(haystack) return indexof(needle[0]). The problem with the set solution is that we do not perserve the order of the elems.

We'll use two pointers. L, R. Loop through with L. If left == first index of needle, save, the index. Then while needle, iterate through both needle and haystack. If same, return index, else, index -1, set L = R. 

for i in range(len(haystack)): 
	if haystack[i] == needle[0]:
		index = i
		for j in len(needle):
			if haystack[j] != needle[j]:
				i, index = j, -1
				break
return index

if not needle:
	return 0
for i in range(len(haystack) - len(needle) + 1): #we do this because we do not need to iterate through the entire len of the haystack if the elem left is < than len needle

        if not needle:
            return 0
        for i in range(len(haystack) - len(needle) + 1):
            if haystack[i] == needle[0]:
                match = True
                for j in range(1, len(needle)):
                    if haystack[i + j] != needle[j]:
                        match = False
                        break
                if match:
                    return i
        return -1

This code looks kind of messy. But its O(n) time and O(1) space. There is actually an algo that we could use called the KMP algo that: 

1) You create a prefix table for the needle. This stores the len of the longest proper prefix for each prefix of the needle. 

**Rewrite of Rotten oranges
R, C = len(grid), len(grid[0])
rotten = deque()
oranges += 1
dir = [[1,0],[-1,0],[0,1],[0,-1]]

for r in R:
	for c in C:
		if grid[r][c] == 2:
			rotten.append(r,c)
		if grid[r][c] == 1:
			oranges += 1

while rotten:
	for nr, nc in dir: 
		if not (0<= nr < R or 0<= nc < C) or grid[nr][nc] == 0 or grid[nr][nc] == 2:
			continue

	grid[nr][nc] == 2
	rotten.append(nr,nc)
	oranges -= 1
	
	if rotten:
		time += 1

return time if oranges == 0 else -1

The cracked version using python list comprehension:
	R, C, time 

//Apr 2 2024
**Rotton Oranges
You want to define R and C. Then you want to create a queue using deque(). The rotton oranges get popped. You also have to iterate through the entire grid to count the total number of oranges. If you hit a time where no oranges get rotten and there is more less rotten than total oranges, return -1, else return time.

R, C = len(grid)-1, len(grid[0])-1
rotten = deque()
oranges = 0

for r in range(R):
	for c in range(C):
		if grid[r][c] == 2:
			rotten.append((r,c), 0)
		elif grid[r][c] == 1
			fresh += 1
#Q: do we even need:
if fresh_oranges == 0:
	return 0

dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]

while rotten: 
	r, c = rotten.popleft()

	for dr, dc in dir:
		nr, nc = r + dr, c + dc

		if not (0<= nr < R and 0 <= nc < C):
			continue
		if grid[nr][nc] == 0 or grid[nr][nc] == 2:
			continue
		
		grid[nr][nc] = 2
		oranges -= 1
		queue.append((nr,nc))

	if queue: 
		time += 1

return time if oranges == 0 else -1 

//Apr 1 2024
**Rotton Oranges
For rotten oranges, we use a queue. Since we're counting the amount of time it takes for all the oranges to rot.

**Add Binary
Covert two strings into int, add, and convert to binary again. How do convert to int? Loop from the back, first val += 2^(i + 2). Do the same for other int. val1 + val2. To convert to binary:

val1, val2 = 0, 0
for i in range(len(a))-1, -1,-1):
	val1 += 2 ^ (i + 1)

How to turn into binary? Gave up on this. 

while num > 0:
	r = num % 2
	bin = str(r) + bin
	n // = 2

Do the loop again. 

Full code:

val1, val2, bin = 0, 0, ''
for i in range(len(a))-1, -1,-1):
	val1 += 2 ^ (i + 1)
for i in range(len(b))-1, -1,-1):
	val2 += 2 ^ (i + 1)
num = val1 + num2
while num > 0:
	r = num % 2
	bin = str(r) + bin
	n // = 2
return bin

another method = return bin(int(a,2) + int(b,2))
[2:]

for i in range(len(a) -1, -1, -1):
	if a[i] == 1:
		val1 += 2 ** (i + 1)

**Number of Islands
To find the number of islands in a grid, you want to loop through the grid and check for 1s. We can't just count the number of ones since mutiple ones can come together to form an island. Once you reach a 1, 1) mark it as visited 2) recursivly spread to other ones. Return count.

For the dfs, you have to check bounds. 

if not grid:
	return 0

R, C = len(grid)-1, len(grid[0])-1 
count = 0

dfs(r,c,grid):
	if r < 0 or r > R or c < 0 or c > C or grid[r][c] == 0:
		return
	else:
		grid[r][c] = '0'
		dfs(r + 1, c , grid)
		dfs(r - 1, c , grid)
		dfs(r, c + 1 , grid)
		dfs(r, c - 1 , grid)

for r in range(R):
	for c in range(C):
		if grid[r][c] == 1:
			count += 1
			dfs(r, c, grid)

return count

Q: How do we shorten this code. We can use list comprehensions: 

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(r, c):
            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == '1':
                grid[r][c] = '0'
                list(map(dfs, (r + 1, r - 1, r, r), (c, c, c + 1, c - 1)))

        return sum(dfs(r, c) or 1 for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == '1')


//Mar 31 2024
Find pivot index 1) find the max sum. Then keep a prefix sum of the left sum. And when sum - left sum = left sum, return index, else return false if reached end of the loop. One thing that you messed up it the bounds. If you ls to be at the bottom before the compare. And ls = total sum - left sum - n. Why the -n? 

Review of diagonal traverse:
Notice how that sum of every diagnoal row index is the same [0], [1,0],[0,1]. So we can add these to a hash map where the key is the sum of the index. We create this map using a O(n)^2 traversal looping with i and j. This way we have all the coordinates of the diagnoal traversal mapped out. Notice that the traversal occurs in alternating directions. We can append diagnal row and diagnal row reversed if % 2 != 0. Now loop through apended index elem and return res. 

Spiral Matrix:
For this question you have to figure out a method to 1) shrink the top, left, right, bottom bounds 2) change traversal directions. 

Todo: Number of Islands
Todo: Rotting Oranges

//Mar 29 2024
**Pascal's Triangle
Solved

//Mar 28 2024
**Pascal's Triangle

[1] a)       0
[1,1] b)     1
[1,2,1]      2 
[1,3,3,1]    3 
[1,4,6,4,1]  4

You're doing a len2 scan from l -> r. edges are always 1. Edge case a) b). Rest follows the two scan patt.

**Spiral Matrix
Q: How do you determine directions: right, down, left, up

Instead of subtracting row, and col, you can make sure top < bottom and left < right:

top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1
res = []

while top <= bottom and left <= right:
	#move right
	while j <= right:
		res.append(matrix[i][j])
		j += 1
	top += 1
	i += 1
	j -= 1

You define r, c = len(matrix), len(matrix[0]). Q: How do you do CW turns?

[0,0], [1,0], [2,0] | [1,2], [2,2] | [2,1], [2,0] | [1,0] | [1,1]
  0      1      2       3      4       3      2       1       2  -> Sum

[0,0], [1,0], [2,0]
[1,2], [2,2]
[2,1], [2,0]
[1,0]
[1,1]

We go from increase to decrease in len. There does not seem to be and clever math/indices trick to figure out like the diagonal traverse.

Brute force. Iterate i -> till R. Turn down. Iterate j till C. Turn Left

row, col, i, j, n, res = len(matrix) - 1, len(matrix[0]) - 1, 0, 0, 0, []
while row > 0 or col > 0:
	if i == 0: #traverse left
		for i in range(col):
			res.append(matrix[i][j])
		n+=1
	elif i == col: #traverse down
		for j in range(n, row):
			res.append(matrix[i][j])
	elif j == row: #traverse left
		for i in range(col - n, -1, -1):
			res.append(matrix[i][j]
	else: #traverse up
		for j in range(row - n -1, -1, -1):
			res.append(matrix[i][j]
return res

[-,-,-]
[|,-,|]
[-,-,|]

row = 3, 2
col = 3, 

Ok, it seems like you mesed up the cases for spiraling inwards. You want to set a top, bottom, left, right var. After each right top +1, move down right -1 since you're iterating from the back, move left bottom -=1, move up, l+=1


**Diagonal Traverse
d = {}
for i in range(len(matrix)):
	for j in range(len(matrix[i])):
		if i + j not in d:
			d[i + j] = [matrix[i][j]]
		else:
			d[i + j].append(matrix[i][j])

This builds the dict. The problem is 70% solved. Now you just have to figure out a method to traverse it in a zig zag pattern. You iterate through d[i+j] and if index % 2 == 0 down up, else go up down. Append to res.

for key, val in d.items():
	if key % 2 != 0:
		res.append(val)
	else:
		res.append(reversed(val))

I gave up and refered to GPT. The trick here is to sum i + j. The key big brained insight is that the elements on the same diagonal has the same i + j sum. Q: How does this help us? Well you could just do sum of diagnal - i to find j. 

Try mapping out [i,j] = [0,0] | [1,0], [0,1] | [0,2], [1,1], [2,0] | [2,1], [1,2] | [2,2]
Try to find the pattern of the [i,j] mapping. 

[0,0]
[1,0], [0,1]
[0,2], [1,1], [2,0]
[2,1], [1,2]
[2,2]

| [0,0] |
| [1,0], [0,1] |
| [2,0], [1,1], [0,2] |
| [3,0], [2,1], [1,2], [0,3] |
| [4,0], [3,1], [2,2], [1,3], [0,4] |
-------------------------------------- Lets splits things up between increase and decrease
| [4,1], [3,2], [2,3], [1,4] |
| [4,2], [3,3], [2,4] |
| [4,3], [3,4] |
| [4,4] |

R1 i start @ 0. As R += 1, i += 1. For each row, i -= 1. Once longest R is reached. First i always longest R. i -= 1 for every row.

The j col, j = j + 1 till len of row, reset = 0. Once it reaches max len, the start of j += 1 each time and j = j + 1. 

for i in range(len(mat)):
	append i number of times, append i -> 0
	clear()
		[0] | [1] [0] | [2] [1] [0] | [3] [2] [1] [0]

for j in range(len(mat)):
	append j number of times, append 0 -> i
	clear()

res_i, res_j = [], []
for i, j in range(len(mat)):
	for _ in range(i - 1, -1, -1):
		res_i.append(i)
	for _ in range(j):
		res_j.append(j)

What ends up happening here is that you have [i] [j] in seperate arrs. So you iterate through both at the same time and append val of the mat in res. The way I'm implementing it, we would not heave to clear.

res = []
for i,j in range len(res_i):
	res.append(mat[res_i[i], res_j[i]])

Ok. Lets just try to solve for this pattern: [0] | [1] [0] | [2] [1] [0] | [3] [2] [1] [0]

//Mar 27 2024
**Diagonal Traverse
lol this question is diabolical. You know that the dir of the traversal goes from 1 -> len(arr) before going back down to 9 again. 

Let try to understand the problem. Quiz Q 1: What is the sum of indices (i, j) for the top right elem of any matrix? 

**Plus One
Given int. Rep digits where digits[i] is ith digit of int. And you add one. 

1st method: turn arr into in, add, return the digits in arr format
val = int(for dig in digits n.join(''))
Wrong syntax, the correct method: 
num = int(''.join(map(str, digits))
return the val + 1 to arr
num = [int(dig) for dig in str(num)]
Ok for this method you have to convert the return digits back to string again. Not worth is.

Loop from the back. Add the last val. If the last val == 9, carry = 1, add one again. If there is a carry and you reach index 0, insert @ 0 index and shift everything back. Ok this is not the most run time optimal because of the insert at the start. Instead of inserting at the start, you could do [1] + [rest of arr] since its more run time efficent. 

for i in range(len(digits) - 1, -1, -1):
	if digits[i] < 9:
		digits[i] + 1
		return digits
	digits[i] = 0
	
	return [1] + digits

**Largest Number At Least Twice of Others
1) sort it
2) check if [-1] > 2 * [-2]

You have to return the index of the largest elem.
You only have to store 2 hashs 1) largest val + index 2) 2nd largest val and index. Loop through the arr using enumerate.

def dominantIndex(nums):
    l1, l2 = [float('-inf'), -1], [float('-inf'), -1]  # Initialize with -1 for indices
    for i, n in enumerate(nums):
        if n > l1[0]:
            l2[0], l2[1] = l1[0], l1[1]
            l1[0], l1[1] = n, i
        elif n > l2[0]:
            l2[0], l2[1] = n, i 
    
    if l1[0] >= 2 * l2[0]:
        return l1[1]
    else:
        return -1

More readable two pass approach:

max_val = max(nums)
max_index = nums.index(max_val)

for i, n in enumerate nums:
	if i != max_index and n * 2 > max_val:
		return -1

return max_index

One thing to note - you can find the index by simply calling nums.index(max_val) which I assume is also O(n)

Linked List questions are hurting me, so I'm going to move into arrays.

**Find Pivot Index
prefixsumR = prefixsumL

Q: what is the shortest method to write a prefix sum:

ls, rs, n = nums, nums, len(nums)
for i in range(1, n):
	ls[i] += ls[i - 1]
for i in range(n - 1, -1, -1):
	rs[i] += rs[i + 1]
	if rs[i] == ls[n - i]:
		return nums[n - i]
return -1

Ok, it seems like you overly complicated the heck out of this question. The most elegent method to solve it is to sum all the nums. Check for left sum. If left sum = total sum - left sum, return i, else return -1. 

sum_, ls = sum(nums), 0
for i, n enumerate(nums):
	return i if ls == sum - ls - n else ls += n
return -1

**Flatten a Mutilevel Doubly Linked List [Incomplete]
It seems like you're just putting the child list right after cur node. This is an insertion problem.

Loop through the linked list. If child, insert child and everything in the child layer between cur, and the next node. We can do this iterativly or recursivly. Lets try both methods.

With the iterative method:
cur = head
while cur:
	if cur.child:
		tmp_layer = cur.next
		cur = cur.child
		while cur.next:
			Q: what if there is another nested child?
	cur = cur.next

I'm pretty sure you NEED recursion to solve this. Because there could be up to n levels no?

For the iterative solution you need a 1) helper function 2) a maunal call stack to maintain. Seems pretty dumb to solve this problem this way.

Recursive solution:

What is the base case? If cur.next = None, return

if head is None:
	return
if head.child = None
	flatten(head.next)
else:
	flatten(head.next)

You have to relink to the next node @ the same level of cur before iterating through all the child though.

Base case + recursive step: The true base case is when cur.next and cur.child all == None. After you find a node with a child, you want to explore it completely. Recursively call on this function on the child node. flatten(cur.child). 

Relinking Nodes: You want to save cur.next somehow in the call stack before traversing the child. Seems like BFS with a queue like structure? Everytime you hit a child, you want to add to queue, and everytime that the call stack is complete, you dequeue the top layer (cur.next) and continue traversing cur.next.

Why is it that you don't have to check for a termination condition? I thought when solving linked lists problems recursively, you always have to return None or something if base case is hit. As for relinking nodes cur = cur.child.

if cur is None:
	return None

OK, I had to cheat for this portion. As I've guessed, you have a temp storage for cur.next. You need that to relink everything after you've traversed through all of the child nodes one layer down. Then you call flatten(cur.child). Ok the one thing I didn't think of is that you need to find the last child - that is the one you have to link back up with the higher level.

The process of relinking the nodes are 1) lastchild.next = tmp, tmp.prev = lastchild. That is if tmp though. I'm still a little confused even when given the code. So lets walk through the DFS step by step.

lastChildNode = cur.child
while lastChildNode.next:
    lastChildNode = lastChildNode.next

With this, you're iterating till you find the last child node in a level. This is how you know where to link the end of the child to the start of the top level. 

lastChildNode.next = next_temp
if next_temp:
    next_temp.prev = lastChildNode

This simply relinks the child level with the parent level.

**Add Two Numbers (Iterative)
Ok so it turns out that I did not need to reverse the nodes.

Correct code: You should initialize a dummy node. set cur as dummy so you can iterate over it. Also, you forgot to iterate prev1 and prev 2. Other than that its correct and you just return dummy.next.

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:
    c1, c2, prev1, prev2 = l1, l2, None, None
    while c1:
        c1.next, prev1, c1 = prev1, c1, c1.next
    while c2:
        c2.next, prev2, c2 = prev2, c2, c2.next

    dummy = ListNode(0)
    cur = dummy
    carry = 0
    while prev1 or prev2 or carry:
        val1 = prev1.val if prev1 else 0
        val2 = prev2.val if prev2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        cur.next = ListNode(total % 10)
        cur = cur.next

        if prev1:
            prev1 = prev1.next
        if prev2:
            prev2 = prev2.next

    return dummy.next

Draft code:

c1, c2, prev1, prev2 = l1, l2, None, None
while c1:
    c1.next, prev1, c1 = prev1, c1, c1.next
while c2:
    c2.next, prev2, c2 = prev2, c2, c2.next

carry = 0
while prev1 or prev2:
	val1 = prev1.val if prev1 else 0
	val2 = prev2.val if prev2 else 0
	sum = val1 + val2 + carry
	carry = sum // 10 
	val = sum % 10
	cur = ListNode(val) 
	cur = cur.next


//Mar 26 2024
**Add Two Numbers (Iterative)
The tricky thing about the iterative solution is that you have to look from R -> L and its a singly linked list. Is there a way to solve it in O(n) time and O(1) space. Is there a way to solve this problem without having to reverse the linked list?

1) Reverse the linked Lists

prev1, prev2, c1, c2 = None, None, l1.head, l2.head
while l1 or l2:
	c1.next, c2 = prev1, prev2
	prev1, prev2 = c1, c2
	c1, c2 = c1.next, c2.next

The problem with this code is that it does not handle the edge cases where the lists are shorter.

The proper method is:

c1, c2, prev1, prev2 = l1, l2, None, None

while c1 or c2:
	if c1:
		c1.next, prev1, c1 = prev1, c1, c1.next
	elif c2:
		c2.next, prev2, c2 = prev2, c2, c2.next
	elif not c1 and c2:
		c1.val, c1 = 0, c1.next
	else:
		c2.val, c1 = 0, c2.next

Ok, we'll handle the edge cases during the addition phase where sum = val1 + val2 + carry. 

c1, c2, prev1, prev2 = l1, l2, None, None
while c1:
    c1.next, prev1, c1 = prev1, c1, c1.next
while c2:
    c2.next, prev2, c2 = prev2, c2, c2.next

1) calculate sum
2) calculate carry
3) create and link new node from val
4) reverse nodes

while c1 or c2:

**Add Two Numbers (Recursive)
According to GPT, you need:

def addTwoNumbers(l1, l2, carry=0): The base case is if carry == 0 and not l1 and not l2. Then you return.

To handle the cases of if there is a val for diff len of linked lists, if l1 = 0 or if l2 = 0.

val1 = l1.val if l1 else 0
same with val2
sum = val1 + val2

carry = sum // 10
cur_val = sum % 10
cur_node = ListNode(cur.val)

recursive case:
next1 = l1.next if l1 else None
same w/ next2
cur_node.next = addTwoNumbers(nex1, next2, carry)


This questions suits recursion pretty well. The base case is if l1 and l2 = None. The recursive case, you want to pas l1, l2 and carry. 

if l1.val + l2.val > 10:
	addTwoNumbers(l1.val + l2.val - 10 ,1) #(sum, carry)
else:
	addTwoNumbers(l1.val + l2.val, 0)

Ok. What do yo make equal to addTwoNumbers? cur.next = addTwoNumbers? How do you handle the carry from a previous recursion?

The trivial solution is wrong - you did not read the questions properly- you're doing addition. The algo for the carry: either 1 or 0. num1 + num2, if > 10, -10 and carry = 1, else carry = 0. Since I'm lazy, I'm going to convert array to int, add, and convert to list again.

arr1, arr2 = [], []
while l1 or l2:
	if l1:
		arr1.append(l1.val)
		l1 = l1.next
	if l2:
		arr2.append(l2.val)
		l2 = l2.next

num1 = int("".join(str(n) for n in arr1))
num2 = int("".join(str(n) for n in arr2))

res = num1 + num2 
return [int(digit) for digit in str(num)]

The return expects a linked list, so just build one and return that

Trivial Solution

arr1, arr2 = [], []
while l1 or l2:
	if l1:
		arr1.append(l1.val)
		l1 = l1.next
	if l2:
		arr2.append(l2.val)
		l2 = l2.next

res = [0] * len(arr1)

for i in range(len(arr1)-1, -1 ,-1):
	res[-i-1] = arr1[i] + arr2[i]

return res

Ok. Did not read the problem correctly. There is a carry term.


**Merge Two Sorted Lists
Ok, lets try to use recursion to solve this. What is the base case? If not l1 or l2. What is the minimizing case? if l1 smaller, l2 = mergeTwoList(l1.next), else l1 = mergeTwoList(l2.next).

if l2 = None: 
	return l1
if l1 = None:
	return l2

if l1.val < l2.val:
	l2 = mergeTowLists(l1.next)
else:
	l1 = mergeTwoLists(l2.next)

First step is to create a dummy prehead node. Q: why is that helpful? This way we don't have to deal with the edge cases of 0 or 1 node in l1 or l2. The condition to decide whether the node from l1 or l2 should be attached to cur node is which is smaller. Compare l1.val to l2.val. Append the smaller one. cur.next = l1, l1 = l1.next. cur = cur.next to iterate. Once all the nodes are attached, you have two cases, where l1 = None or l2 = None. Take the one that is not None, and cur = l2/l1.next. Return head. 

dummy = newNode(None, next = head)
cur = dummy
while l1 and l2:
	if l1.val < l2.val:
		cur.next = l1
		l1 = l1.next
	else:
		cur.next = l2
		l2 = l2.next
	cur = cur.next

if l1 is not None:
	cur.next = l1
if l2 is not None: 
	cur.next = l2 

return dummy.next

The case that you missed is that you also have to return l1 and return l2 inside the case of l1.val <> l2.val. Why is that 

//Mar 25 2024
**Merge Two Sorted Lists
I remeber that there was a way to do it recursively and iterivly. Lets try solving it with a while loop first.

while l1 and l2, if l1 smaller, add that first, else add l2. when adding the flow looks something like (when comparing next vals). 

**Palindrome Linked List
Q: How do we do it in O(n) time and O(1) space? It seems like we would have to move 2 pointers at different speeds. The tricky part here is that its a uni-directional linked list.

1 -> 2 -> 3 -> 3 -> 2 -> 1

So using the fast and slow pointers you can find the midpoint. The tricky thing is how we do the comparisions.

1) you cant have a set, hash, or any other external storage 2) you can't create prev pointer (counts as extra storage) 

But you can reverse the linked list before the midpoint. Recall reversing a linked list:

cur.next = prev
prev = cur
cur = cur.next

count, cur, cur2, prev, f = 0, head, head, None, head
while f and f.next:
	count += 1
	cur = cur.next
	f = f.next.next

for _ in range(count//2):
	cur2.next = prev
	prev = cur2
	cur2 = cur.next

for _ in range(count//2):
	if cur2.val != cur.val:
		return False
	cur, cur2 = cur.next, cur2.next

return True

Few things to observe 1) Count is not needed. 2) You didn't handle the case of if not head or head.next.

if not head or not head.next:
	return True

s = f = head
prev = None

while f and f.next:
	f, s.next, prev, s = f.next.next, prev, s, s.next

if f:
	s = s.next

while prev and s:
	if prev.val != slow.val:
		return False
	prev, s = prev.next, s.next

return True

The most trivial method to do this is to traverse through the linked list and append each elem onto an array. Then you perform is Palindrome on the arry. for i in range(len(arr) // 2) and for j in range(len(arr)//2) is the same.

res, cur = [], head
while cur:
	res.append(cur.val)
	cur = cur.next

for i in range(len(res)//2):
	if res[i] != res[-i-1]:
		return False

return True

**Odd Even Linked List

You offset odd and even. Store where even started. Iterate while even and even.next. The key is you are not just iterating through via .next.next but rather you have to update the nodes with odd.next = odd.next.next, then move odd.

Ok, my main mistake is the fact that I traversed the linked list twice. No need for that. First and foremost, if there is no head, I should return None - that is the edge case. Set odd = head and even to be one offset. while there is even and even.next (since thats the longest node). Holy smokes, the idea of setting an evenHead is pretty smart. evenHead = even. 

Store all the odd vals and even vals. Then combine the linked list.

cur, odd = even = head
e, o = 0, 0
while odd.next:
	odd = odd.next.next
	o += 1
while even.next:
	even = even.next.next
	e += 1
for _ in range(e+o):
	cur = odd.next
	if odd.next == None:
		cur = even.next
return cur

Ok, you can't do odd.next.next. You have to start them offset by eachother.

**Remove Linked List Elements
Loop through the linked list. If val cur.val == val remove. Keep going till head == null.

You can look to see if cur.next.val == val. Since this is a singly linked list. we only really have to move one pointer.

cur.next = cur.next.next. We don't have to worry about two pointers. 

cur = head
while cur.next:
	if cur.next.val == val:
		cur.next = cur.next.next
	cur = cur.next
return head

Q1: My code would return 1 -> 2 -> 6 -> 4 -> 5 -> None? 
Q2: For Q2 you can check and modify the head pointer before the while loop, or easier yet, use a tmp dummy node

For the edge cases of these linked list, its good to have a dummy node:

dummy = ListNode(next=head)
cur = dummy
while cur.next:
	if cur.next.val == val:
		cur.next = cur.next.next
	else:
		cur = cur.next
	return dummy.next

//Mar 24 2024
**Reverse a linked
while loop. You have a tmp store. 

tmp = cur.next
cur.next = cur.prev
cur.prev = cur.next
cur = tmp

The elegent way to implement is cur, prev = head, None
while there is a cur, cur.next = prev, prev = cur, cur = cur.next. So what you wrote above was wrong.

**Intersection of Two LinkedLists
Most elegent version of the solution does not require counting. If any of the list elems are empty, return None. You set a and b to their respective heads. while a != b, you keep looping. 

a = a.next if a else headB
b = b.next if b else headA

Followup: write solution that is O(m+n) time and O(1) mem. So I cheated a bit and looked at the solution for O(1) space. You calculate the len of both arr and offset the len of the longer one by starting at len(long) - len(short).

a, b, len_a, len_b = headA, headB, 0, 0
while a:
	a = a.next
	len_a += 1
while b:
	b = b.next
	len_b += 1

if len_a > len_b:
	diff = len_a - len_b
	for _ in range(diff):
		a = a.next
	while a and b:
		a, b = a.next, b.next
		if a == b:
			return a

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a, b = headA, headB
        len_a, len_b = 0, 0

        # Calculate the length of list A
        while a:
            len_a += 1
            a = a.next

        # Calculate the length of list B
        while b:
            len_b += 1
            b = b.next

        # Reset pointers to the start of each list
        a, b = headA, headB

        # Adjust the starting point for the longer list
        if len_a > len_b:
            for _ in range(len_a - len_b):
                a = a.next
        else:
            for _ in range(len_b - len_a):
                b = b.next

        # Find the intersection
        while a != b:
            a = a.next
            b = b.next

        # Either both are None (no intersection) or both are at the intersection point
        return a

Can we not store the vals of a1 and b1 in a hash? If val in hash, return. 

a = headA
b = headB
a_list = set() 

while a.next:
	a_list.add(a)
	a = a.next

while b.next:
	if b in a_list:
		return b
	b = b.next 

return None

Corrected code: 

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a_nodes = set()

        # Traverse the first list and add all nodes to the set
        a = headA
        while a:
            a_nodes.add(a)
            a = a.next

        # Traverse the second list and check each node against the set
        b = headB
        while b:
            if b in a_nodes:
                return b  # Intersection found
            b = b.next

        return None  # No intersection

**Linked List Cyle II
Shortened version according to GPT. Cycle detection is still the same. The diff starts to happen while you're in the outer loop. if s == f. while head != s, you move head. 

s = f = head
while f and f.next:
	s, f = s.next, f.next.next

Code:
s = f = head
while f and f.next:
	f, s = f.next.next, s.next
	if s == f:
		break

cycle, ptr = 1, ptr.next
while ptr != s:
	ptr = ptr.next
	cycle += 1

ptr1 = ptr2 = head
for _ in range(cycle-1):
	ptr1, ptr2 = ptr1.next, ptr2.next
return ptr1

peudo code I:

step 1
c1, c2 = 0, -1
s = f = head
while f and f.next:
	f = f.next.next
	s = s.next
	c1 += 1
	if f == s:
		break
#observation, we don't even have to track c1 here

step 2
ptr = s.next
while ptr != s:
	ptr = ptr.next
	c2 += 1

step 3
ptr1 = ptr2 = head
while c2 >= 0:
	ptr2 = ptr2.next
	c2 -= 1
res = 0
while ptr1 != ptr2:
	ptr1 = ptr1.next
	ptr2 = ptr2.next
	res += 1
return res

The first thing we want to establish is that f can cross s at an 'arbitrary' location dependent on 1) where the cycle starts 2) the size of the cycle (number of nodes). This means if we can find 2) the size of the cycle, we can reverse engineer to where the cycle starts based on where they cross. 

Step 1:
To solve this, there is a couple of questions we have to answer 1) To detect if there is a cycle, we start both s and f at head, moving f 2x as fast as s. If s == f, there is a cycle. 

Step 2: 
To determine the size of the cycle you take the point where s == f. And s = s.next, fast = fast.next.next. Doing it with a cycle len of 4, (1,2,3,4 nodes) it seems like s moves 2x the length of the list before f catches up. So would the equation just be count s moved since s==f // 2?

step 3:
You just do count s==f location - size of cycle? 

Ok for step 2, you can just keep looping f till s == fast again and track the count. Ok, now the giga brain move is set up another ptr1 and ptr2. You move ptr1 by len of cycle at a time. ptr2 1 step at a time? '

You initalize ptr1 to be n steps ahead and iterate 1 @ a time. Q: why does this work? Since you know that one point is exactly n len further ahead, you know that pt1 will == pt2 in which its the start of the linked list.

Just to clearify for step 2 you start @ s == f, and you only iterate 1 ptr till you hit s==f again. And you simply count the number of increments?

Its the same as normal cycle detection, but you simply add an index counter no? There is the base case:

if not head or not head.next:
	return -1

f = s = head
p = 0
while f and fast.next:
	p += 1
	f = fast.next.next
	s = slow.next
	if f == s:
		return p
return -1

This does not work because the point in which f and s meet does not mean its where the cycle starts

Read into Two Pointer in LinkedList: To determine if cycle, you can use hash table or f and s pointer. 

Q: How would you do cycle detection and find the start of a cycle?

**Linked List Cycle
Pretty much, you move fast twice fast as slow. If fast == slow, return true, else return false. Q: what is the while condition? While fast.next.next and slow.next. 

**Design Linked List
def deleteAtIndex(self, index):
	if index == 0:
		self.head = self.head.next
		self.size -= 1
	elif index == self.size:
		self.tail = self.tail.prev
		self.size -= 1
	elif index > size:
		return -1
	else:
		cur = self.head
		while cur.next and index < size:
			cur = cur.next
			index -= 1
		cur.next.prev = cur.prev
		cur.prev.next = cur.next

Lets compare how my code is diff from GPTs. If index < 0 or index >= self.size return -1. Valid, this is a more general case. If index == 0, self.head = self.head.next. If self.head you also have to remove the tail that pointed back to the prev head. The other case is if there is no more head, then you set self.tail = None. If its at the end, there are two cases as well. -> wait no the other case where the list = empty just activates the condition above to remove head. self.tail = self.tail.prev, self.tail.next = None. You dont have to do while cur.next since its already managed by index. The key is that you do cur.prev.next = cur.next before cur.next.prev = cur.prev. 

The correct code: 

def deleteAtIndex(self, index):
    if index < 0 or index >= self.size:
        return -1
    elif index == 0:
        self.head = self.head.next
        if self.head:
            self.head.prev = None
        else:
            self.tail = None
    elif index == self.size - 1:
        self.tail = self.tail.prev
        self.tail.next = None
    else:
        cur = self.head
        while index > 0:
            cur = cur.next
            index -= 1
        cur.prev.next = cur.next
        cur.next.prev = cur.prev
    self.size -= 1
    return 0

//Mar 22 2024
**Design Linked List
Ok, lets first make a class called ListNode which should contain the def for node, and node val. I forgot the def. But I think you need something along the lines of 1) new node 2) node vals: 

class ListNode:
	def __init__(self, val):
		self.val = val
		self.prev = None
		self.next = None

For the above, its the inital initialization. For the MyLinkedList class, you want to define that the self.left. 

For the def of myLinkedList, it can vary a lot by if its a singly, or doublely linked list. Generally, for the node class you want to declare the val, prev and next. For the init for the MyLinkedList you would want to set the head, tail vals. 

One intresting thing you can also add is the size of the linked list. For example, if you constantly need to know the length of the list, instead of having to iterate through the list at O(n) time, you can look at the size attribute which is O(1). 

class MyListNode:
	def __init__(self):
		self.head = None
		self.tail = None
		self.size = 0

Ok, now for the def of add at head. There are two possible scenarios 1) its an empty linked list 2) its not a empty list.

1) If list, head = ListNode(val), tail = head, size = 1
2) Else head.prev = ListNode(val), head = head.prev, size += 1

def addAtHead(self, val):
	if not head:
		head = ListNode(val)
		tail = head
		size = 1
	else:
		tmp = head
		head.prev = ListNode(val)
		head = head.prev
		head.next = tmp
		size += 1

There is a few issues with how I wrote addAtHead. I mainly forgot to had self. Ok self = making changes to instance in python class. 

if not self.head:
	self.head = ListNode(val)
	self.tail = self.head
	self.size = 1
else:
     tmp = self.head
     self.head = ListNode(val)
     self.head.next = tmp
     tmp.prev = self.head
     self.size += 1

What I fogot was to make tmp.prev = self.head. I feel like there is a better name for tmp. maybe old_head.

Try to shorten:
self.head = ListNode(val) if not self.head else (self.head.prev = ListNode(val, self.head, None)

For the case of adding at tail, similar to adding at head, there are two cases: 1) adding tail to an empty arr 2) adding tail to an non empty arr. Question: how to add to the tail of an arr?

def addAtTail(self, val):
	if not self.tail:
		self.head = ListNode(val)
		self.tail = self.head 
		self.size = 1
	else:
        	self.tail.next = ListNode(val)
        	self.tail.next.prev = self.tail
        	self.tail = self.tail.next
        	self.size += 1

Another way to write the else case of addaAtHead:

else: 
	self.head.prev = ListNode(val)
	self.head.prev.next = self.head
	self.head = self.head.prev
	self.size += 1

  val <-> 1 <-> 2 <-> 3
   ^   
   h

def get(self, index):
	if index > self.size or index < 0:
		return -1
	cur = self.head
	while index > 0:
		cur = cur.next
		index -= 1
	return cur.val

def addAtIndex(self, index, val):
	if index > self.size or index < 0:
		return -1 
	elif index == size:
		addAtTail(val)
	elif index == 0:
		addAtHead(val)
	else:
		new_node = ListNode(val)
		cur = self.head
		while index > 0:
			cur = cur.next
			index -= 1
		new_node.next = cur.next
		new_node.prev = cur
		cur.next.prev = new_node
		cur.next = new_node
		self.size += 1

def deleteAtIndex
	
There are 4 links that you have to break. 

//Mar 21 2024
Started studying recursion
**Reverse String
Base case. When the string is empty, return res. Else keep returning reverseString(s[-1])

if not s:
	return res
res.append(reverseString(s[-1)])

The problem is that you have to declare res outside. And you need to create a helper function.

2nd try
res = [] 
def helper(s):
	if not s:
		return res
	helper(s.pop())

The problem with this helper code is that its simplying the index I want to remove. 

The solution that takes advantage of the call stack uses the following approach: The base case is if the index reaches len(s) // 2. That means you made every swap possible from the l and r side. The recursive case is s[i], s[-i-1] = s[-i-1], s[i]. Then you simply call the function iterating index + 1

def reverseString(s, i=0):
	if i >= len(s) // 2:
		return
	s[i], s[-i-1] = s[-i-1], s[i]
	reverseString(s, i+1)

**Squares of a Sorted Array
We are not allowed to 1) sort 2) square the elem. Take everything < 0, abs val it. reverse. nums1. nums2 = other half. loop through nums1 and nums2. Append to res in that order.

nums1, res = [], []
i = 0
while nums[i] < 0:
	nums1.append(nums[i]
	i += 1
nums1 = reversed(nums1)

k = 0
for j in range(i, len(nums)):
	while num[j] > nums1[k]:
		res.append(nums1[k])
		k+=1
	res.append(nums[j]
return res

Clean up mistakes:

def sortedSquares(nums):
    nums1, res = [], []
    i = 0
    while i < len(nums) and nums[i] < 0:
        nums1.append(abs(nums[i])**2)
        i += 1
    nums1 = list(reversed(nums1))

    k = 0
    for j in range(i, len(nums)):
        while k < len(nums1) and nums1[k] < nums[j]**2:
            res.append(nums1[k])
            k += 1
        res.append(nums[j]**2)

    while k < len(nums1):
        res.append(nums1[k])
        k += 1

    return res

**Find All Numbers Disappeared in an Array
There is a few edge cases to consider 1) if the skip num is at the start 2) if the skip num is at the end, 3) if there are repeats (not really a edge case to worry about). The question is if we can do it in O(n) time. Lets try the leetcode cheat sheet: https://leetcode.com/explore/interview/card/cheatsheets/720/resources/4725/

Arr is not sorted and its asking to find specific elems. The solution therefore uses a hashmap. Remeber you can only do O(n), but that does not mean you have to do only one pass.

Q: Does 1-n include numbers bigger than n in the input? Assume no.

Find len(nums). Turn that into a set. Loop through nums. If not in set, append to solution.

arr, res = set(), []
for i in range(len(nums)):
	arr.add(i)

for num in nums:
	if num not in arr:
		res.append(num)

return res

Ok that was pretty poo poo brained of you. You make nums a set, and check if its not in arr!

n = len(nums)
nums = set(nums)
res = []
for i in range(n):
	if i not in nums:
		res.append(i)
return res

Problem: You have to one index the arr. We fixed that by simply doing n+1 and not appending the 0th i elem.

//Mar 20 2024
**Third Maximum Number
O(n) solution means that we would not be able to sort. What if you maintain a res arr. For example res = [3rd largest, 2nd largest, largest]. Also we do not need a set.

for num in nums:
	if num > 3rd < 2nd, replace 3rd
	if nums > all, replace largest
	if nums > 2nd < largest, replace 3rd. 
	Else do nothing

res = [float('-inf')] * 3
for num in nums:
    if num > res[0] and num < res[2]:
        res[0] = num
    elif num > res[1] and num < res[2]:
        res[1] = num
    elif num > res[2]:
        res[2] = num
if len(res) >= 3:
    return res[0]
else:
    return res[-1]

The problem we face with this solution is that when comparing num < res[2] to neg inf, its always true. Therefore, you have to swap. Lets convience ourselves with an example: 

With [3,2,1], you get a res of [3, inf, inf]. Therefore you have to perform a swap everytime you add. Shift everything to the right in the new arr: 

res[0], res[1], res[2] = num, res[0], res[1]

//Mar 19 2024
**Move Zeros
You have a read and write pointer.

[0,1,0,3,12]
   r
 w 

If == 0, move r up and r, w = r, w, swapping the elems

[1,0,0,3,12]
   r
 w

Lets start with w = 0, r = 1

[0,1,0,3,12]
 w
   r

If nums[w] == 0, nums[r], nums[w] = nums[r], nums[w], w += 1, r += 1

[1,0,0,3,12]
   w
     r

[1,0,0,3,12]
     w
       r

swap

[1,0,3,0,12] -> This fails

The trick is to do it swap if its not 0. And if you do the swap, increment l. 


**Replace Elements with Greatest Element on Right Side
For these replace elem questions, you normally want to iterate from R -> L. Why? So you don't have to look foward and backtrack. The array is not sorted. for i in range(len(arr) - 1, - 1, -1). set num[-1] = -1. next val == max(cur, cur[i+1]

2nd last elem == max(cur, -1). Why not manually set arr[-2] = arr[-1], arr[-1] = -1

arr[-1] = -1
for i in range(len(arr)-2, -1, -1):
	arr[i] = max(arr[i+1], arr[i])
return arr

Input: [17,18,5,4,6,1]
Answer: [18,18,5,4,1,-1]
Expected: [18,6,6,6,1,-1]

Ok, you can't manually set arr[-2]. What if you just set arr[-1]? 
[17,18,5,4,6,-1]

for i in range(len(arr) -2, -1, -1):
	arr[i] = max(arr[i+1], arr[i])
arr[-1] = -1
return arr

It seems like they are shifting everything to the left by +1. I'm too brain dead - the new solution suggested by GPT is as follows. You set max_val = -1. And for i in range(len(arr)-1,...) tmp = cur val, set cur to max_val, and max_val is now = max(max_val, temp).

Q: Just for practice, can you solve this problem via swapping? #todo

**Valid Mountain Array
if cur always larger than prev (increse). Second there is decrease, only allow decrease. If increase again return false.

1) while increase, always increase

increase = True
for i in range(1, len(arr)):
	if arr[i] < arr[i+1] and increase: #this is the peak of the mountain
		increase = False
	if not increase and arr[i] > arr[i+1]:
		return False
return True

Try again while a while loop

i, downhill = 1, False
while arr[i] > arr[i-1]:
	i += 1
downhill = True
while arr[i] < arr[i-1]:
	i += 1
return i == len(arr)

**Check if N and Its Double Exist

It seems like you have to iterate two pointers i and j. Return true if: 1) i != j 2) i and j within arry bounds 3) the val of i == 2x that of j.

Make a set. If new val, add to set. If the val you see // 2 is in set with no reminders. Return true. Else return false.

dup = set()
for num in arr:
	if num % 2 == 0 and num // 2 in dup:
		return True
	elif num not in dup:
		dup.add(num)
return False

This code breaks here because it can only make a comparison to j after its's been added. A cheecky fix is to dup = set(arr). if num%2 == 0 and num // 2 in dup, return True. 

It broke with the following test case: [-2,0,10,-19,4,6,-8]. This fails because 0//2 and %2 == 0. Don't add 0 to set. One way is to never all 0s to the set. res_set = {x for x in arr if x! = 0}. You also have a if case for 0 zeros. Jank as hell. 

Visit the proper way to do it via deletions. 1) sort the reversed(sorted(arr)). Have i, j pointer. Move j by default. Move i if arr[j] * 2 < arr[i] i+= 1.

arr = reversed(sorted(arr))
while j < len(arr) - 1:
	if arr[j] * 2 == arr[i]:
		return True
	elif arr[j] * 2 < arr[i]:
		i += 1
	j += 1
return False


//Mar 18 2024

Count the # of zeros. Iterate backwords. This way you don't have to worry about shifting vals in the indexes.

[1,0,2,3,0,4,5,0]
               ^
You have a zero count which is 3 in this case. You hit the case of if i + zeros < n: which it fails. arr[i] == 0, so you -= 0. zeros = 2. You also go into the case of i + zeros < n which it fails. Do nothing.

[1,0,2,3,0,4,5,0]
             ^
zeros = 2... you keep moving left till arr[i+zeros] < len(arr). What about the case of case of zeros at the back of the index that we would not duplicate? Why are we counting those? I would assume that we would push elements out of the array. But we solve this problem by decrementing everytime we see an 0. For the array [1,2,0,3,0,4,0]
				  ^
i + zeros = 6 + 3 = 9 > len(arr). We then hit the case of arr[i] == 0: zero -= 1. i + zeros > n. Continue loop.

Merge Sorted Array

The cheating way to do it is to use extra space. declare nums3 = []. Loop through nums1 and nums2. Sort it. And for every i-th elem in num you set as nums1[i].

tmp = []
for num in nums1:
    tmp.append(num)
for num in nums2:
    tmp.append(num)
for i, num in enumerate(sorted(tmp)):
    nums1[i] = num

//Mar 16 2024

881 Boats to Save People

For the problem you want to sort the arr. You'll most likely run into the case where there is 1 boat per person because of the limit. You want to check if people[i] and people[i+1] <= limit. If yes, we move the pointer to +2, else + 1 and we increment the number of boats by one.

reversed(people.sorted())

Actually the order of the sort does not matter that much. 

i, boats = 0, 0
people.sort()
while i < len(people) - 2
	if people[i] + people[i + 1] <= limit:
		boats += 1
		i += 2
	else:
		boat += 1 
		i += 1
return boats

Refined code: 
        boats, i = 0, 0
        people.sort()
        while i < len(people):
            if i + 1 < len(people) and people[i] + people[i + 1] <= limit:
                boats += 1
                i += 2
            else:
                boats += 1
                i += 1
        return boats

#1,2,4,5

The code fails at the test case above. So we need two pointers L and R that converge towards the center. Recall even with the L and R pointer there is a case of += 2 boat and += 1 boat. If people [L] + people[R] < target. boats += 1, R += 1. If smaller than target boat += 2 L+= 1, R -=1

boats, L, R = 0, 0, len(people)
while L < R:
	if people[L] + people[R] < target:
		boat += 2
		L += 1
		R -= 1
	else:
		boat += 1
		R -= 1
return boats

We can simplify the expression more:
	if people[L] + people[R] <= limit:
		L += 1
	R -= 1
	boats +=1
return boats

This way we do not have to manually handle the +1 or +2 boat cases.
	
//Mar 6 2024
Answers:
1) The two different (parts?) of graphs are the vertices (nodes or values) and the edges (connect different nodes).

2) The most efficient way to represent a graph where the nodes are connected to a lot of other nodes is through adjacency lists. You can represent another node val by simply adding another char to the list.

3) Between DFS and BFS to find the shortest path of a unweighted graph, I would imagine you would want to use DFS. DFS, goes all the way to the end before trying again. The probability that you find a shortest path that way vs traversing slowing and equally in all directions is a lot higher sooner.

4) For depth first search you either use recursion or simulate the call stack using a stack.

Iterative:
stack = [first node]
while stack:
	for every node connected to first node:
		stack.append(connected nodes)
	cur = stack.pop()
	do something with cur

Recursive:
dfs(node):
	if node = null:
		return
	for every node connected to first node:
		cur = dfs(cur)

5) Shortest path finding for a map app? 

Correct Answers:
1) Directed vs undirected graphs
2) Dense graphs should use [?] if its unweighted, use a 2D boolean array. Why? Complexity = O(V^2)
3) For shortest path, BFS is more useful - Why? It guarantees the first time a node is reached

//Mar 7 2024
Q1: How would you iterate over each cell in the grind?
A1: In a grind there are rows(r) and columns (c). To traverse through the grid, [col][row]. The ways you can move are left ([c][r-1]), right ([c][r+1]), up ([c-1][r]), down ([c+1][r]).

GPT4 method to iterate:

for r in range(len(gird)):
	for c in range(len(grid[0])):
		#process cell grid[r][col]

Q2: Given a cell, how do you check if its land and start DFS from it?
A2: Oh I think I understand where this is going. Loop through the grid at O(n^2) till you find and island (1). Then you do DFS to mark all of the 1s in that insland as visited (maybe by changing 1 -> 0). And you have some external counter var for the # of islands. To answer your Q2:

if grid[r][c] == 1:
	dfs(grid[r + 1][c])
	dfs(grid[r - 1][c])
	dfs(grid[r][c + 1])
	dfs(grid[r][c - 1])

GPT4: The base case for DFS is 1) the bounds check 2) the land check. To check for bounds you do: 

1. if r < 0, r > len(gird), c < 0 or c > len(grid)
2. or grid[r][c] = '0'

Then you set the island to 0. 

Q3: How would you now describe handling the recursive DFS calls to ensure we fully explore each island?
A3: This recusrive call allows the function to navigate through the entire island by checking if there is any other peice of island around it in all directions. This applies to all the connected grid[r][c]. The only way for the recursion to end is if the call stack completes by hitting grid[r][c] == 0 or its out of bound, both meaning that the island ended.

Implement the DFS Function:

dfs(grid, r, c):
	if r < 0 or c < 0 or r > len(grid) or c > len(grid[r]) or grid[r][c] == 0:
		return

	islands += 1
	grid[r][c] = 0

	dfs(grid, r + 1, c)
	dfs(grid, r - 1, c)
	dfs(grid, r, c + 1)
	dfs(grid, r, c - 1)

Q4: Can you think of any optimizations or edge cases? 
A4: If the grind is all zero or 1, you can either return 0 or 1. However that will be O(n^2) no? I wonder if there is a more efficent way to handle these edge cases. 

1st attempt at writing func: 

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        islands = 0

        for r in range(len(grid)):
            for c in len(grid[r]):
                if grid[r][c] == 1:
                    dfs(grid, r, c)
                    islands += 1

        def dfs(grid, r, c):
            if r < 0 or c < 0 or r > len(grid) or c > len(grid[r]) or grid[r][c] == 0:
                return
            grid[r][c] = 0
            dfs(grid, r + 1, c)
            dfs(grid, r - 1, c)
            dfs(grid, r, c + 1)
            dfs(grid, r, c - 1)

        return islands

Problem #463

def islandPerimeter(self, grid: List[List[int]]) -> int:
	def dfs(grid, r, c, calls):
		if r < 0 or c < 0 or r > len(grid) or c > len(grid[r]) or grid[r][c] == 0:
			return calls += 1
		dfs(grid, r + 1, c, calls)
            	dfs(grid, r - 1, c, calls)
            	dfs(grid, r, c + 1, calls)
            	dfs(grid, r, c - 1, calls)
	
	for r in range(len(grid)):
		for c in len(grid[r]):
			if grid[r][c] == 1:
				dfs(r, c, 0)

#The key thing to realize is that the number of times that the island is touching water is simply the number of calls on the call stack

Max Area of Island: 
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        def dfs(r, c):
            if r<0 or c<0 or r>=ROWS or c>=COLS or grid[r][c] == 0:
                return 0
            grid[r][c] = 0
            area = 1
            area += dfs(r+1, c)
            area += dfs(r-1, c)
            area += dfs(r, c+1)
            area += dfs(r, c-1)
            return area

        maxArea = 0
        for r in range(ROWS):
            for c in range(COLS):
                if grid[r][c] == 1:
                    maxArea = max(maxArea,dfs(r, c))
        return maxArea      

Problem 994. Rotting Oranges:
def orangesRotting(self, grid: List[List[int]]) -> int:
	ROWS, COLS = len(grid), len(grid[0])
	def dfs(grid, r, c):
	if r < 0 or c < 0 or r >= ROWS or c >= COLS or grid[r][c] == 0 or grid[r][c] == 2:
		return
	grid[r][c] = 2
	dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)

	for r in range(ROWS): 
		for c in len(COLS):
			if grid[r][c] == 2:
				dfs(grid, r, c)

DFS does not work for rotting oranges as the uniform spread alone with the time tracking makes it easier to do BFS. 

To visit the next cell, add to queue, you loop through its neighbors, by [r+1][c], [r-1][c], [r][c+1], [r][c-1] and cur is simply queue.pop() checking if its == 0, 1, or 2. If its 2, spread the rot. += 1 to level. You set the 1s you visited to 2 to ensure you don't revisit. You keep repeating this while stack to ensure that all the oranges are rotten. The only conditions in which the stack is empty is 1) you reached every part of the grid 2) all the surroundings are either 2 or 0, meaning that there is no more oranges to rot.

form collections import deque
def prepareInitialQueue(grid):
	ROWS, COLS = len(grid), len(grid[0])
	rottenOrangesQueue = deque()

	for r in range(ROWS):
   		for c in range(COLS):
        		if grid[r][c] == 2:
				rottenOrangesQueue.append((r, c), 0)

	return rottenOrangesQueue


Mon Mar 11 2024

392. Is subsequence [SOLVED ON PLANE]

s_set, tmp = set(s), ''
for i in range(len(t)):
	if i in range(len):
		if t[i] in s_set:
			tmp += t[i]
if tmp == s:
	return True
else:
	return False

#Q, what if there are repeated letters in the subset - don't have to worry about it as it is a subsequence problem

334. Increasing Triplet Subsequence

#Recall that a greedy algo works for a problem where you can solve it by just solving
#the local optimum
#The first part to the problem is that you solve the sub problem of [i, j] and nums[i] #< nums[j]

#Q: what is the starting condition?

i, j, k = 0, 1, 2
while i < len(nums) - 2 and j < len(nums) -1 and k < len(nums):
	if nums[i] < nums[j] < nums[k]:
		return True
	elif nums[i] > nums[j]
		#iterate till you solve it


		i += 1
	elif nums[i] < nums[j] > nums[k]:
		j += 1
	else:
		k += 1
return False

Q what is the logic to iterate?

[1, 2, 3, 4, 5]
 i  j  k

In this example we return true

[2, 1, 5, 0, 4, 6]
 i
       j

                k

#The index condition will be taken care of the i, j, k loop
#you want to return False unless triplet found

#Another way to solve it- solve for the i j case first with a loop.
#Start another loop with k where 

i, j = 0, 1
while i < len(nums) - 2 and j < len(nums) - 1:
	if nums[i] > nums[j]:
		j += 1

Save vals

From now you can only iterate k 

We can actually rewrite that as

i, j = 0, 1
while j < len(nums) - 1:
	if nums[i] > nums[j]:
		j += 1
	else:
		break

k = j
while k < len(nums) - 1:
	if nums[j] > nums[k]
		k += 1
	else:
		return True
return True

Ok now lets try to break this. Imagine the test case: [5,4,3,1,2,3] -> this should return true @ for 1, 2, 3. However we're not moving i. So this fails. 

Q: how do you increment i? 

[5,4,3,1,2,2,8,1] -> This should return True
 i
     j

q: would it work if you save the min val that j has passed for i to index to?
if nums[i] > j_min:
	move i to j_min position

[5,4,3,1,2,2,8,1]
       i
         j


j_min = 1


1ST HALF CODE

i, j, j_min = 0, 1, nums[1]
while j < len(nums) - 1:
	if nums[i] > nums[j]
		j += 1
		j_min = min(j_min, nums[i])
		if nums[i] > j_min:
			i = j
	else:
		return True
return False

Now add the k index

-TODO...

March 12 2024

1171. Remove Zero Sum Consecutive Nodes from Linked List

You could use a while loop, although recursion is the most elegant solution. 

The first sub problem to solve: How to remove the consecutive elements:

if cur.val == cur.next.val: delete

Q: How do you delete two nodes at once?

[1, 2, -3, 3, 1]

Mar 13 2024

Ok let me walk you through what I am thinking. You have the vars i, j, k to track which indexes are able to return True. The starting condition has to be i, j, k = 0, 1, 2. The min possible val for nums[1] 

Next, the while loop of while j < len(nums) - 2 and k < len(nums) - 1: works because if j > len(nums)-2, or k = len(nums)-1, that means nums[i] < nums[j] < nums[k] and i < j < k would not be possible so we break it. Otherwise its fair game. 

Ok look at the line if nums[i] > nums[j]: That means we have to move j up to search for a j value that might fulfil nums[i] < nums[j] < nums[k]. We have to ensure that k > j. The mistake I made was j += 1 and k += 1 right away where I should've done if j = k, then k += 1. 

Now we need to keep j_min = min(j_min, nums[i]) because lets say in the example [5,4,3,1,2,2,8,1] we don't want to keep incrementing j till the end while i stays @5. Therefore if the j_min or a passed j value is smaller than i, we would want to move i there. Thus the code: 

                j_min = min(j_min, nums[i])
                if nums[i] > j_min:
                    i = j
                    j += 1


The problem with that is that you end up storing the lowest possible value. What you have to do instead is reset j_min and k_min at every cycle of the loop to the possible vals instead of the global min.

        while j < len(nums) - 2 and k < len(nums) - 1:
            j_min = nums[i]
            k_min = nums[j]

Ok now we add the k elem. Now we can repeat the logic for nums[j] > nums[k]. At the start of every loop, we set k_min = nums[j]. And then: 

            if nums[j] > nums[k]:
                k += 1
                k_min = min(k_min, nums[j])
                if nums[j] > k_min:
                    j = k
                    k += 1


Easy proof: if not nums[i] > nums[j] and not nums[j] > nums[k], that means nums[i] < nums[j] < nums[k] no? How can nums[i] be bigger than nums[k] if nums[i] < nums[j] and nums[j] < nums[k] for example? 

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        i, j, k = 0, 1, 2
        while j < len(nums) - 2 and k < len(nums) - 1:
            j_min = nums[i]
            k_min = nums[j]
            if nums[i] > nums[j]:
                j += 1
                if j == k:
                    k += 1
                j_min = min(j_min, nums[i])
                if nums[i] > j_min:
                    i = j
                    j += 1
            if nums[j] > nums[k]:
                k += 1
                k_min = min(k_min, nums[j])
                if nums[j] > k_min:
                    j = k
                    k += 1
            else:
                return True
        return False

[] TODO: FIGURE OUT WHAT IS WRONG WITH THIS ********

Q: to self-> why does this code not work? According to GPT:

To counter the dumb ass shit it said: 

1) j_min and k_min 

200 Number of Islands:
Do DFS on all the islands, set them to 0. # of islands += 1. Return # of islands

=> Input: Grid

ROW, COL = len(grid) - 1, len(grid[0]) - 1

#loop through the arry to find islan

num = 0

for r in ROW:
	for c in COL:
		if grid[r][c] == 1:
			dfs(grid, r, c)
			num += 1

dfs(grid, r, c):
	if r < ROW and c < COL and r >= 0 and c >= 0 and not grid[r][c]:
		return
	grid[r][c] = 0
	dfs(grid, r + 1, c)
	dfs(grid, r - 1, c)
	dfs(grid, r, c + 1)
	dfs(grid, r, c - 1)

return num

605 Can Place Flowers

input: flowerbed [], n int

#What you do is simply find the max number of flowers you should be able to plant

for i in range(len(flowerbed) - 1):
	if flowerbed[i] == 0 and flowerbead[i-1] == 0 and flowerbead[i+1] == 0
		count += 1

There are a few edge cases for first and last elem = 0 

[0, 0, 1, 0 , 0, 0, 1]
We can solve this by if flowerbed[0] and flowerbed[1] both == 0, += 1. Start on the 3rd index. 
For range(3, len(flowerbed) - 3)

Q; How about [...1, 0, 0] we can handle that case by only iterating till the 2nd last elem

Putting this all together:

count = 0

if flowerbead[0] == 0 and flowerbed[1] == 0:
	count += 1

if flowerbed[-1] == 0 and flowerbed[-2] == 0: 
	count += 1

for i in range(4, len(flowerbed) - 4):
	if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] == 0
		count += 1

return count >= n

Ok. For the edge cases, what you could do is just set the vals to 1. Edge case of len(1)?

Solved by having a case of len(flowerbed) == 0

238. Product of Array Except Self

[1,2,3,4] -> [24,12,8,6]

Try mutiplicative prefix sum:

[1, 2, 6, 24]   
[24,24,12,4 ]

Val * last val
[1,2,6,12]
[2,6,12,4]

The problem I ran into above is the fact that I did in inclusive

left_arr, right_arr, res = len(nums) * [1], len(nums) * [1], []

for i in range(1, len(nums)): 
	left_arr[i] = nums[i-1] * left[i-1]

for i in range(len(nums) - 2, -1, -1)
	right_arr[i] = nums[i+1] * left[i+1]

for i in range(len(nums)):
	res.append(left_arr[i] * right_arr[i])

930. Binary Subarrays With Sum

This is a sliding window problem with a binary sum. Lets pretend its not binary. How would you generally solve a sliding
window problem? 

LOL I thought it would be legit binary calculation. No we just counting the numbers of ones. We can do that with a prefix sum easily.

nums = [1,0,1,0,1], goal = 2
In this example the prefix sum
[1,1,2,2,3] if R - L + 1 = goal

Ok now that we figured out how to efficently calculate the sum of window elems lets make the sliding window

prefix = [num[0]]
for i in range(1, len(nums)):
	prefix.append(prefix[-1] + nums[i])

L, R, solutions = 0, 0, 0
while R < len(nums):
	if L == 0:
		if goal == prefix[R]:
			solutions += 1
			R += 1
	elif prefix[R] - prefix[L - 1] == goal:
		solutions += 1
		R += 1
	elif prefix[R] - prefix[L] + 1 < goal:
		R += 1
	else:
		L += 1

return solutions

The correct method to calcualte the prefix sum is actually [R] - [L-1]

Corrected version of the code according to GPT4: 

prefix = [0]
for nums in nums:
	prefix.append(prefix[-1] + num)

L, R, solutions = 0, 0, 0
while R < len(prefix) - 1: 
	cur_sum = prefix[R + 1] - prefix[L]
	
	if cur_sum == goal:
		solutions += 1
		R += 1
	elif cur_sum < goal:
		R += 1
	else: 
		L += 1

return solutions

This is a repeat of 930. Binary Subarrays With Sum

Q1: A sub array is a smaller portion of an array defined by a left and right bound. 
Q2: The naive way is to brute force at O(n^2). Have an i and j pointer. Iterate i by one and every time iterate j from i -> len(nums). 
Q3: Sliding window can be applied for this problem because we know that if a previous sub array overshot the target, ex [1,1,1,0] where target = 2, we know that we can skip over a portion of the arrays thus turning this to O(n^2).
Q4: Basic Sliding Window:

solutions == 0
l, r = 0, 0
while l < len(nums) - 1:
	if nums[l] + nums[r] == target:
		solutions += 1
		r += 1 #try to increase r, if its a 0, we can continue adding solutions
	elif nums[l] + nums[r] < target:
		r += 1 
	else:
		l += 1

One thing I'm thinking with this code is if we might be overshooting with R. Would we ever have l += 1 and then set r = l?

Q5: In the above code, you would increase l += 1 if sum nums[l] nums[r] > target to shrink the window 
Q6: If the sum of l and r == target, we can increase a counter.
Q7: One edge case that my code previously failed at is: [0,0,0,0,1,0,0,0,0] target == 0. I remeber failing a test case similar where the return val was 1 larger than it should've been. 

Ok. What is wrong with the current sliding window implementaion?

Q: how to we handle the case of sum == target? Brainstorming: 
1) Move right foward
2) mark l and r val as visited solution in set
3) try l -= 1, r += 1

The key is that we have to check if nums[l] + nums[r] == target repeat

while nums[l] + nums[r] == target:
	solutions += 1
	r += 1

Still not refined enough. Lets try to traverse through a prefix sum? Its not the most efficent

For the sliding window, if you're not using the prefix sum, you can +- the number 1s in the window by doing a check to see if nums[l], nums[r] == 0 or 1. You can keep a sum count this way at O(1) space and O(n) time complexity

pesudo code: 
solutions, window_sum = 0, 0
while l < len(nums)
	if wind_sum == target:
		solutions += 1
		r += 1
		window_sum += nums[r]
	elif window_sum < target:
		r += 1
		window_sum += nums[r]
	else:
		window_sum -= nums[l]
		l += 1

Refined version
l, r = 0, 0
window_sum = 0
solutions = 0

while r < len(nums): 
	window_sum += nums[r]
	
	while window_sum > target < 1 <= r:
		window_sum -= nums[l]
		l += 1

	if window_sum == target:
		solutions += 1
		tmp_l = 1
		while temp_l < r and nums[tmp_l] == 0:
			solutions += 1
			temp_1 += 1

735. Asteroid Collision

Pop from the stack twice. That will be the collisions. If same direction, append both to stack. If oppsite dir, append only the bigger one to the new stack. Q: do you continue till no more collisons? It seems like it. 

First step lets add to the stack:

stack = []
while asteroids:
	a1 = asteroids.pop()
	a2 = asteroids.pop()
	if (a1 > 0 and a2 > 0) or (a1 < 0 and a2 < 0):
		stack.append(a1)
		stack.append(a2)
	elif a1 > a2: 
		stack.append(a1)
	else:
		stack.append(a2)

Cool, now that we have this, how do we keep crashing them till? A: We should create a def func that we call till 1) empty 2) all > 0 3) all < 0

neg, pos = False, False
while stack or (not neg and pos) or (not pos and neg):
	for i in range(len(asteroids)):
		if neg and pos:
			neg, pos = False, False
			collide(asteroids)
		elif asteroids[i] > 0:
			pos = True
		else:
			neg = True

def collide(asteroids):
	stack = []
	while asteroids:
		a1 = asteroids.pop()
		a2 = asteroids.pop()
		if (a1 > 0 and a2 > 0) or (a1 < 0 and a2 < 0):
			stack.append(a1)
			stack.append(a2)
		elif a1 > a2: 
			stack.append(a1)
		else:
			stack.append(a2)
	return stack

Question: why do we not need another def function for this problem
Few assumptions: The collision logic is not complex enough to need to be abstracted out into its own function- it can all be handles in a while loop

stack = []
for asteriod in asteriods:
	collison = False
	while stack and asteriod < 0 < stack[-1]:
	
Ok so with         while stack and asteroid < 0 < stack[-1]: you're appending all of the neg val asteroid

Think about the base case. By default, there is no collision, you stack.append. Then there is the collision case: 
If we face an asteriod and the stack is not empty we check which one is bigger. The key here is to mark collision as True and break that while loop so we don't hit the case of if not collision, stack.append.

2126. Destroying Asteroids
The key to this problem is that you can sort the asteroids. That gives the planet the best chance because that max the size of the planet at every interval. Don't need stack. 

sorted(asteroids)

for asteroid in asteroids: 
	if mass > asteroid: 
		mass += asteroid
	else:
		return False
return True

739. Daily Temperatures

Use a stack. We're trying to map:
[73,74,75,71,69,72,76,73]  -> 
[1,1,4,2,1,1,0,0]

pop from the tempatures stack. Add to another tmp stack. I think the trick is how many times you have to pop from the tmp stack till you get a val that is larger.

stack = [tempatures.pop()]
res = []

while tempatures:
	count = 0
	tempature = tempatures.pop()
	while tempature > stack[-1]:
		stack.pop()
		count += 1
	res.append(count)
	stack.append(tempature)

Lets manually go through an interation: 

[73,74,75,71,69,72,76,73]
tempature =
count =
Stack =
Res =

This approach is not correct. Apprently you track the index of each day in the stack. 

If given a specific day's tmp, the most simple method is to iterative till next warmer tmp and count # of iterations. However, you could the index of the last highest tmp into the stack. And then to find number of days, you can do last higher index - cur index to find the number of days. 

You want to store the index val of the date.
Q: When do you add to stack?
Q: When do you pop from the stack?

Wait wtf is a monotonic stack?

Mar 15 2024

For a problem where you need to find the next greater element in array, why would you not want a regular stack? To be fair, I'm not sure how you would solve it efficiently with a regular stack. The brute force method to solve this is to iterate through i and make a comparsion to j every time which is O(n^2). Another way I wrote the other day for a similar question is to count the number of times a tmp stack gets popped(). This still seems O(n^2) as you would have to pop n elem, and add it again for the next iteration. What I'm thinking about is if there is a O(n) way to just count the number of pops. Perhapes making a set of the index + vals?

When you encounter an element greater than stacks top elem, I would guess that you keep popping until the last elem of the stack is larger? no idea lol. on 5 hours of sleep too tired to work it out myself (is that bad that I'm this lazy?)

Q: How does this provide O(n) run time? Recall for a monotonic stack, you only add the largest elem, and you keep popping from the stack till you 1) find an elem 2) there is no more elems in the arry. My knee jerk response is to count the number of pops. My but I recall that a problem stored the index elems. When you come upon the largest elem you find the diff between the index vals to find out how far they are apart from another. 
